[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cartographie avec R",
    "section": "",
    "text": "Préambule\nCe manuel est destiné aux utilisateurs de R souhaitant mettre en place des traitements de données spatiales et créer des cartes ainsi qu’aux géomaticiens et cartographes souhaitant utiliser R pour réaliser les tâches qu’ils réalisent habituellement avec un SIG ou un logiciel de cartographie.\nLa première partie est dédiée à la création de cartes thématiques conformes aux règles de la sémiologie graphique et de la cartographie avec R.\nLa deuxième partie aborde les principales étapes du traitement de l’information géographiques et la manipulations de données spatiales.\n\n\n\n\n\n\nCe document est dérivé de deux supports de cours plus complets : Cartographie avec R (Giraud et Pecout, 2023a) et Géomatique avec R (Giraud et Pecout, 2023b).\n\n\n\n\n\n\n\nGiraud, T. et Pecout, H. (2023a). Cartographie avec R. https://doi.org/10.5281/zenodo.7528161\n\n\nGiraud, T. et Pecout, H. (2023b). Géomatique avec R. https://doi.org/10.5281/zenodo.7528145"
  },
  {
    "objectID": "manip_donnees_vectorielles.html#le-package-sf",
    "href": "manip_donnees_vectorielles.html#le-package-sf",
    "title": "1  Manipuler les données vectorielles",
    "section": "1.1 Le package sf",
    "text": "1.1 Le package sf\n Le package sf (Pebesma, 2018) a été publié fin 2016 par Edzer Pebesma. Ce package permet l’import, l’export, la manipulation et l’affichage de données spatiales vectorielles. Pour cela sf s’appuie sur une série de bibliothèques spatiales : GDAL (GDAL/OGR contributors, 2022) et PROJ (PROJ contributors, 2021) pour les opérations d’import, d’export et de projection, et GEOS (GEOS contributors, 2021) pour les opérations de géotraitement (buffer, intersection…).\nCe package propose des objets simples (suivant le standard simple feature) dont la manipulation est assez aisée. Une attention particulière a été portée à la compatibilité du package avec la syntaxe pipe (|&gt; ou %&gt;%) et les opérateurs du tidyverse (Wickham et al., 2019).\nL’utilisation du package sf est l’objet de la deuxième partie de ce document (chapitre 6 et suivants)."
  },
  {
    "objectID": "manip_donnees_vectorielles.html#format-des-objets-spatiaux-sf",
    "href": "manip_donnees_vectorielles.html#format-des-objets-spatiaux-sf",
    "title": "1  Manipuler les données vectorielles",
    "section": "1.2 Format des objets spatiaux sf",
    "text": "1.2 Format des objets spatiaux sf\n\nLes objets sf sont des data.frame dont l’une des colonnes contient des géométries. Cette colonne est de la classe sfc (simple feature column) et chaque individu de la colonne est un sfg (simple feature geometry).\nCe format est très pratique dans la mesure ou les données et les géométries sont intrinsèquement liées dans un même objet."
  },
  {
    "objectID": "manip_donnees_vectorielles.html#import-de-données",
    "href": "manip_donnees_vectorielles.html#import-de-données",
    "title": "1  Manipuler les données vectorielles",
    "section": "1.3 Import de données",
    "text": "1.3 Import de données\nLa fonction st_read() permet d’importer de nombreux types de fichiers.\nLes lignes suivantes importent la couche des communes du département du Lot situé dans le fichier geopackage lot.gpkg.\n\nlibrary(sf)\n\n#&gt; Linking to GEOS 3.9.0, GDAL 3.2.2, PROJ 7.2.1; sf_use_s2() is TRUE\n\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\")\n\n#&gt; Reading layer `communes' from data source \n#&gt;   `/home/tim/Documents/prz/PUDS_2023/PUDS_2023/data/lot.gpkg' \n#&gt;   using driver `GPKG'\n#&gt; Simple feature collection with 313 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668\n#&gt; Projected CRS: RGF93 / Lambert-93"
  },
  {
    "objectID": "manip_donnees_vectorielles.html#affichage",
    "href": "manip_donnees_vectorielles.html#affichage",
    "title": "1  Manipuler les données vectorielles",
    "section": "1.4 Affichage",
    "text": "1.4 Affichage\n\n1.4.1 Aperçu des variables\nLes objets sf peuvent être explorés avec les fonctions head(), summary() ou plot() par exemple.\n\nhead(com)\n\n#&gt; Simple feature collection with 6 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 556391.9 ymin: 6371852 xmax: 614866.5 ymax: 6418606\n#&gt; Projected CRS: RGF93 / Lambert-93\n#&gt;   INSEE_COM         NOM_COM         STATUT POPULATION     AGR_H    AGR_F\n#&gt; 1     46001           Albas Commune simple        522  4.978581 0.000000\n#&gt; 2     46002          Albiac Commune simple         67  0.000000 9.589041\n#&gt; 3     46003        Alvignac Commune simple        706 10.419682 0.000000\n#&gt; 4     46004         Anglars Commune simple        219  0.000000 0.000000\n#&gt; 5     46005 Anglars-Juillac Commune simple        329  4.894895 4.894895\n#&gt; 6     46006   Anglars-Nozac Commune simple        377  4.840849 0.000000\n#&gt;       IND_H     IND_F     BTP_H    BTP_F     TER_H     TER_F\n#&gt; 1  4.936153  0.000000  9.957527 0.000000 44.917145 34.681799\n#&gt; 2  0.000000  0.000000  4.794521 0.000000  4.794521  9.589041\n#&gt; 3 10.419682  5.209841 10.419682 0.000000 57.308249 78.147612\n#&gt; 4 20.000000 15.000000 10.000000 0.000000 20.000000 20.000000\n#&gt; 5  4.894895  0.000000  0.000000 0.000000 29.369369 29.369369\n#&gt; 6  0.000000  0.000000  9.681698 4.840849 43.567639 38.726790\n#&gt;                             geom\n#&gt; 1 MULTIPOLYGON (((559262 6371...\n#&gt; 2 MULTIPOLYGON (((605540.7 64...\n#&gt; 3 MULTIPOLYGON (((593707.7 64...\n#&gt; 4 MULTIPOLYGON (((613211.3 64...\n#&gt; 5 MULTIPOLYGON (((556744.9 63...\n#&gt; 6 MULTIPOLYGON (((576667.2 64...\n\nsummary(com)\n\n#&gt;   INSEE_COM           NOM_COM             STATUT            POPULATION     \n#&gt;  Length:313         Length:313         Length:313         Min.   :   49.0  \n#&gt;  Class :character   Class :character   Class :character   1st Qu.:  172.0  \n#&gt;  Mode  :character   Mode  :character   Mode  :character   Median :  300.0  \n#&gt;                                                           Mean   :  555.7  \n#&gt;                                                           3rd Qu.:  529.0  \n#&gt;                                                           Max.   :19907.0  \n#&gt;      AGR_H            AGR_F            IND_H             IND_F        \n#&gt;  Min.   : 0.000   Min.   : 0.000   Min.   :  0.000   Min.   :  0.000  \n#&gt;  1st Qu.: 0.000   1st Qu.: 0.000   1st Qu.:  4.843   1st Qu.:  0.000  \n#&gt;  Median : 5.000   Median : 0.000   Median :  5.516   Median :  4.943  \n#&gt;  Mean   : 6.935   Mean   : 2.594   Mean   : 16.395   Mean   :  7.635  \n#&gt;  3rd Qu.:10.013   3rd Qu.: 5.000   3rd Qu.: 19.715   3rd Qu.:  9.905  \n#&gt;  Max.   :56.179   Max.   :24.641   Max.   :602.867   Max.   :184.016  \n#&gt;      BTP_H             BTP_F             TER_H             TER_F        \n#&gt;  Min.   :  0.000   Min.   : 0.0000   Min.   :   0.00   Min.   :   0.00  \n#&gt;  1st Qu.:  0.000   1st Qu.: 0.0000   1st Qu.:  10.00   1st Qu.:  15.15  \n#&gt;  Median :  5.000   Median : 0.0000   Median :  20.00   Median :  30.26  \n#&gt;  Mean   :  9.572   Mean   : 0.9723   Mean   :  42.17   Mean   :  60.77  \n#&gt;  3rd Qu.: 10.329   3rd Qu.: 0.0000   3rd Qu.:  44.69   3rd Qu.:  63.95  \n#&gt;  Max.   :203.122   Max.   :16.9238   Max.   :1778.87   Max.   :2397.18  \n#&gt;             geom    \n#&gt;  MULTIPOLYGON :313  \n#&gt;  epsg:2154    :  0  \n#&gt;  +proj=lcc ...:  0  \n#&gt;                     \n#&gt;                     \n#&gt; \n\nplot(com)\n\n#&gt; Warning: plotting the first 9 out of 12 attributes; use max.plot = 12 to plot\n#&gt; all\n\n\n\n\n\n\n\n1.4.2 Affichage de la géométrie uniquement.\n\nplot(st_geometry(com))"
  },
  {
    "objectID": "manip_donnees_vectorielles.html#exercice",
    "href": "manip_donnees_vectorielles.html#exercice",
    "title": "1  Manipuler les données vectorielles",
    "section": "1.5 Exercice",
    "text": "1.5 Exercice\n\nLes données utilisées dans ce document sont stockées dans un projet RStudio. Vous devez le télécharger puis le décompresser sur votre machine. Il vous sera ensuite possible de tester l’ensemble des manipulations proposées dans ce document au sein du projet geodata.\nTélécharger le projet\nNous utiliserons le package sf dans la suite de cette formation.\nInstallez le en utilisant la fonction install.packages().\n\n\n\n\n\nGDAL/OGR contributors. (2022). GDAL/OGR Geospatial Data Abstraction software Library. Open Source Geospatial Foundation. https://doi.org/10.5281/zenodo.5884351\n\n\nGEOS contributors. (2021). GEOS coordinate transformation software library. Open Source Geospatial Foundation. https://libgeos.org/\n\n\nPebesma, E. (2018). Simple Features for R: Standardized Support for Spatial Vector Data. The R Journal, 10(1), 439‑446. https://doi.org/10.32614/RJ-2018-009\n\n\nPROJ contributors. (2021). PROJ coordinate transformation software library. Open Source Geospatial Foundation. https://proj.org/\n\n\nWickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L. D., François, R., Grolemund, G., Hayes, A., Henry, L., Hester, J., Kuhn, M., Pedersen, T. L., Miller, E., Bache, S. M., Müller, K., Ooms, J., Robinson, D., Seidel, D. P., Spinu, V., Takahashi, K., et al.Yutani, H. (2019). Welcome to the tidyverse. Journal of Open Source Software, 4(43), 1686. https://doi.org/10.21105/joss.01686"
  },
  {
    "objectID": "mapsf.html#présentation",
    "href": "mapsf.html#présentation",
    "title": "2  mapsf",
    "section": "2.1 Présentation",
    "text": "2.1 Présentation\n\nL’écosystème spatial du logiciel libre R est riche, dynamique et mature et plusieurs packages permettent d’importer, de traiter et de représenter les données spatiales. Le package mapsf (Giraud, 2022) s’appuie sur cet écosystème pour intégrer la création de cartes thématiques de qualité dans les chaînes de traitements avec R.\n\n\n\nUne chaîne de traitements typique\n\n\n\n\n\n\n\n\nD’autres packages peuvent être utilisés pour réaliser des cartes thématiques.\nLe package ggplot2 (Wickham, 2016), en association avec le package ggspatial (Dunnington, 2023), permet par exemple d’afficher des objets spatiaux et de réaliser des cartes thématiques simples.\nLe package tmap (Tennekes, 2018) est dédié à la création de cartes thématiques, il utilise une syntaxe proche de celle de ggplot2 (enchaînement d’instructions combinées avec le signe +).\nLa documentation et les tutoriels pour utiliser ces deux packages sont facilement accessibles sur le web.\n\n\n\nDans ce document, nous utiliserons principalement le package mapsf dont les fonctionnalités sont assez complètes et la prise en main plutôt simple. De plus, le package est relativement léger.\n\n\n\nUn nombre minimal de dépendances bien connues\n\n\nmapsf permet de créer la plupart des types de carte utilisés habituellement en cartographie statistique (cartes choroplèthes, typologies, symboles proportionnels ou gradués…).\nPour chaque type de carte, plusieurs paramètres permettent de personnaliser la représentation cartographique. Ces paramètres sont les mêmes que ceux que l’on retrouve dans les logiciels de SIG ou de cartographie usuels (par exemple, le choix des discrétisations et des palettes de couleurs, la modification de de la taille des symboles ou la personnalisation des légendes).\nAssociées aux fonctions de représentation des données d’autres fonctions sont dédiées à l’habillage cartographique (thèmes ou chartes graphiques, légendes, échelles, flèches d’orientation, titre, crédits, annotations…), à la création de cartons ou à l’export des cartes.\nmapsf est le successeur de cartography (Giraud et Lambert, 2017), il offre les mêmes fonctionnalités principales tout en étant plus léger et plus ergonomique."
  },
  {
    "objectID": "mapsf.html#documentation",
    "href": "mapsf.html#documentation",
    "title": "2  mapsf",
    "section": "2.2 Documentation",
    "text": "2.2 Documentation\n\nUn site web\n\n\n\nUne vignette ‘Get started’.\nDes vignettes ‘How to’ :\n\nHow to create faceted maps\nHow to create inset maps\nHow to export maps\nHow to use a custom font family\nHow to use themes\n\nUne cheat sheet"
  },
  {
    "objectID": "mapsf.html#exercice",
    "href": "mapsf.html#exercice",
    "title": "2  mapsf",
    "section": "2.3 Exercice",
    "text": "2.3 Exercice\n\nInstallez le package mapsf.\nQuelle est la version du package?\nQuelles sont les nouveautés par rapport à la version précédente?\n\n\n\n\n\nDunnington, D. (2023). ggspatial: Spatial Data Framework for ggplot2. https://CRAN.R-project.org/package=ggspatial\n\n\nGiraud, T. (2022). mapsf: Thematic Cartography. https://CRAN.R-project.org/package=mapsf\n\n\nGiraud, T. et Lambert, N. (2017). Reproducible Cartography. M. Peterson (dir.), Cham, Switzerland (p. 173‑183). https://doi.org/10.1007/978-3-319-57336-6_13\n\n\nTennekes, M. (2018). tmap: Thematic Maps in R. Journal of Statistical Software, 84(6), 1‑39. https://doi.org/10.18637/jss.v084.i06\n\n\nWickham, H. (2016). ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. https://ggplot2.tidyverse.org"
  },
  {
    "objectID": "semio.html#principes-généraux",
    "href": "semio.html#principes-généraux",
    "title": "3  La sémiologie graphique",
    "section": "3.1 Principes généraux",
    "text": "3.1 Principes généraux\n\nLa sémiologie graphique est, de façon générale, l’ensemble des règles qui régissent la construction d’un système de signes ou langage permettant la traduction graphique d’une information. Depuis la parution de la Sémiologie graphique de Jacques Bertin (1967), elle désigne surtout un ensemble standardisé des règles et de pratiques inhérentes à la représentation cartographique au-delà des travaux réalisés par Bertin.\nwikipedia\n\n\nLa sémiologie graphique utilise les propriétés de l’image visuelle pour faire apparaitre les relations de différence, d’ordre et de proportionnalité entre les données.\nD’après Bertin (1967)\n\nPour une première approche de la cartographie thématique on peut se référer à la figure suivante qui résume de manière simplifiée la relation entre un type de variable et sa représentation graphique correcte.\n\n\n\n\n\n\n\nPourquoi on ne représente pas de stocks en aplat !\n\n\n\n\n\n\n\n\n\nQuelques ouvrages de référence en cartographie thématique : Bertin (1967), Pumain et Béguin (2010), Lambert et Zanin (2016)."
  },
  {
    "objectID": "semio.html#exercice",
    "href": "semio.html#exercice",
    "title": "3  La sémiologie graphique",
    "section": "3.2 Exercice",
    "text": "3.2 Exercice\n\nComment représenter les variables suivantes :\n\nUne population communale\nUn age median par département\nUn taux de croissance\nLe statut administratif d’une commune (préfecture, sous-préfecture, commune simple…)\nL’espérance de vie par pays\n\nLa carte suivante représente les résultats de l’élection présidentielle américaine par comtés en 2016 (rouge = républicain, bleu = démocrate).\nQuel est le problème avec cette carte (outre le manque d’habillage, titre etc.)?\n\n\nclick anywere!\n\n\n\n\nBertin, J. (1967). Sémiologie Graphique. Les Diagrammes - Les Réseaux - Les Cartes. Paris: Mouton & Gauthier-Villars.\n\n\nLambert, N. et Zanin, C. (2016). Manuel de cartographie: principes, méthodes, applications. Armand Colin.\n\n\nPumain, D. et Béguin, M. (2010). La représentation des données géographiques: Statistique et cartographie. Armand Colin."
  },
  {
    "objectID": "type_de_carte.html#les-données-dexemple",
    "href": "type_de_carte.html#les-données-dexemple",
    "title": "4  Les types de cartes",
    "section": "4.1 Les données d’exemple",
    "text": "4.1 Les données d’exemple\nLes lignes suivantes importent les couches d’information spatiales situées dans le fichier geopackage lot.gpkg.\n\nlibrary(sf)\n# import des communes du Lot\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\n# import des départements français\ndep &lt;- st_read(\"data/lot.gpkg\", layer = \"departements\", quiet = TRUE)\n# import des restaurants\nresto &lt;- st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\n# import des routes autour de la commune de Gramat\nroute &lt;- st_read(\"data/lot.gpkg\", layer = \"routes\", quiet = TRUE)"
  },
  {
    "objectID": "type_de_carte.html#afficher-un-fond-de-carte",
    "href": "type_de_carte.html#afficher-un-fond-de-carte",
    "title": "4  Les types de cartes",
    "section": "4.2 Afficher un fond de carte",
    "text": "4.2 Afficher un fond de carte\nUtilisée sans précision de type, la fonction mf_map() affiche simplement le fond de carte.\n\nlibrary(mapsf)\n# Communes\nmf_map(x = com, border = \"white\")\nmf_map(x = dep, lwd = 2, col = NA, add = TRUE)\nmf_map(x = route, lwd = .7, col = \"ivory4\", add = TRUE)\nmf_map(x = resto, pch = 20, cex = .7, col = \"darkred\", add = TRUE)"
  },
  {
    "objectID": "type_de_carte.html#carte-de-symboles-proportionnels",
    "href": "type_de_carte.html#carte-de-symboles-proportionnels",
    "title": "4  Les types de cartes",
    "section": "4.3 Carte de symboles proportionnels",
    "text": "4.3 Carte de symboles proportionnels\nLes cartes de symboles proportionnels sont utilisées pour représenter les variables de stocks (variables quantitatives absolues, la somme et la moyenne ont un sens). La fonction mf_map(..., type = \"prop\") propose cette représentation.\n\n# Communes\nmf_map(x = com)\n# Symboles proportionnels\nmf_map(\n  x = com, \n  var = \"POPULATION\",\n  type = \"prop\",\n  leg_title = \"Population totale\\n(2015)\"\n)\n# Titre\nmf_title(\"Distribution de la population dans le Lot\")"
  },
  {
    "objectID": "type_de_carte.html#carte-choroplèthe",
    "href": "type_de_carte.html#carte-choroplèthe",
    "title": "4  Les types de cartes",
    "section": "4.4 Carte choroplèthe",
    "text": "4.4 Carte choroplèthe\nLes cartes choroplèthes sont utilisées pour représenter les variables de ratios (variables quantitatives relatives, la moyenne a un sens, la somme n’a pas de sens).\nLa fonction mf_map(..., type = \"choro\") permet de créer des cartes choroplètes. Les arguments nbreaks et breaks servent à paramétrer les discrétisations.\n\n# Densité de population (hab./km2) en utilisant la fonction sf::st_area()\ncom$DENS &lt;- 1e6 * com$POP / as.numeric(st_area(com))\nmf_map(\n  x = com,\n  var = \"DENS\",\n  type = \"choro\",\n  breaks = \"quantile\",\n  nbreaks = 6,\n  pal = \"Dark Mint\",\n  lwd = 1,\n  leg_title = \"Densité de population\\n(habitants par km2)\", \n  leg_val_rnd = 0\n)\nmf_title(\"Distribution de la population dans le Lot (2018)\")\n\n\n\n\n\n4.4.1 Les palettes de couleurs\nL’argument pal de mf_map() est dédié au choix d’une palette de couleur. Les palettes fournies par la fonction hcl.colors() peuvent être utilisées directement.\n\nmf_map(x = com, var = \"DENS\", type = \"choro\",\n       breaks = \"quantile\", nbreaks = 4, pal = \"Mako\")\n\n\n\n\n\nLa fonction mf_get_pal() permet de construire une palette de couleur. Cette fonction est surtout utile pour créer des palettes divergentes asymétriques équilibrées.\n\nmypal &lt;- mf_get_pal(n = c(6,3), palette = c(\"Burg\", \"Teal\"))\nimage(1:9, 1, as.matrix(1:9), col=mypal, xlab = \"\", ylab = \"\", xaxt = \"n\",\n      yaxt = \"n\",bty = \"n\")\n\n\n\n\n\n\n4.4.2 Discrétisations\nLa fonction mf_get_breaks() met à disposition les méthodes de discrétisations de variables classique : quantiles, moyenne/écart-type, amplitudes égales, moyennes emboîtées, Fisher-Jenks, géométrique…\n\nx &lt;- com$DENS\nhtitle &lt;- \"Population density distribution\"\nhlab &lt;- \"inh. per km2\"\npar(mar = c(5.1,2.1,2.1,2.1), mfrow = c(3,1))\nhist(x = x, n = 25, main = htitle, xlab = hlab, freq = FALSE)\nboxplot(x, horizontal = TRUE)\nstripchart(x = x, method = \"jitter\", pch = 21, bg = \"red\", \n           col = \"white\", cex = .9)\n\n\n\n\nCette distribution est très dissymétrique à gauche. L’utilisation de la méthode “geom” est assez appropriée dans ce cas.\n\nbks &lt;- mf_get_breaks(x = x, nbreaks = 6, breaks = \"geom\") \ncols &lt;- mf_get_pal(n = 6, palette = \"SunsetDark\", rev = TRUE)\npar(mfrow = c(1,1))\nhist(x = x, breaks = bks, col = cols, xlab = hlab, freq = F,\n     axes = FALSE, ylab = \"\", main = htitle, border = \"grey80\",\n     lwd = 3, ylim = c(-0.01, 0.03), xlim = c(0,600))\nstripchart(x = x, pch = 21, bg = \"grey20\", col = \"white\", \n           at = -0.005, jitter = 0.0025, add = TRUE,\n           method = \"jitter\", cex = .7, xlab = \"\")\naxis(side = 1, at = seq(0,600,100))\npoints(x = bks, y = rep(0, length(bks)), pch = \"|\")\n\n\n\n\n\nmf_map(x = com, var = \"DENS\", type = \"choro\",\n  breaks = bks, pal = cols,\n  lwd = 1,\n  leg_title = \"Population density\\n(inh. per km2)\", \n  leg_val_rnd = 0\n)\nmf_title(\"Population distribution in the Lot department\")"
  },
  {
    "objectID": "type_de_carte.html#carte-de-typologie",
    "href": "type_de_carte.html#carte-de-typologie",
    "title": "4  Les types de cartes",
    "section": "4.5 Carte de typologie",
    "text": "4.5 Carte de typologie\nLes cartes de typologies sont utilisées pour représenter les variables qualitatives.\nLa fonction mf_map(..., type = \"typo\") propose cette représentation.\n\nmf_map(\n  x = com,\n  var=\"STATUT\",\n  type = \"typo\",\n  pal = c(\"aquamarine4\", \"yellow3\",\"wheat\"),\n  lwd = .7,\n  leg_title = \"\"\n)\nmf_title(\"Statut Administratif\")\n\n\n\n\nL’argument val_order sert à ordonner les modalités dans la légende.\n\nmf_map(\n  x = com,\n  var=\"STATUT\",\n  type = \"typo\",\n  pal = c(\"aquamarine4\", \"yellow3\",\"wheat\"),\n  val_order = c(\"Préfecture\", \"Sous-préfecture\", \"Commune simple\"),\n  lwd = .7,\n  leg_title = \"\"\n)\nmf_title(\"Statut Administratif\")"
  },
  {
    "objectID": "type_de_carte.html#carte-de-stocks-et-de-ratios",
    "href": "type_de_carte.html#carte-de-stocks-et-de-ratios",
    "title": "4  Les types de cartes",
    "section": "4.6 Carte de stocks et de ratios",
    "text": "4.6 Carte de stocks et de ratios\nLa fonction mf_map(..., var = c(\"var1\", \"var2\"), type = \"prop_choro\") représente des symboles proportionnels dont les surfaces sont proportionnelles aux valeurs d’une variable et dont la couleur repose sur la discrétisation d’une seconde variable. La fonction utilise les arguments des fonctions mf_map(..., type = \"prop\") et mf_map(..., type = \"choro\").\n\nmf_map(x = com)\nmf_map(\n  x = com,\n  var = c(\"POPULATION\", \"DENS\"),\n  type = \"prop_choro\",\n  border = \"grey50\",\n  lwd = 1,\n  leg_pos = c(\"topright\", \"topleft\"),\n  leg_title = c(\"Population\", \"Densité\\nde population\\n(en hab./km2)\"),\n  breaks = \"q6\",\n  pal = \"Magenta\",\n  leg_val_rnd = c(0,1))\nmf_title(\"Population\")"
  },
  {
    "objectID": "type_de_carte.html#carte-de-stocks-et-de-catégories",
    "href": "type_de_carte.html#carte-de-stocks-et-de-catégories",
    "title": "4  Les types de cartes",
    "section": "4.7 Carte de stocks et de catégories",
    "text": "4.7 Carte de stocks et de catégories\nLa fonction mf_map(..., var = c(\"var1\", \"var2\"), type = \"prop_typo\") représente des symboles proportionnels dont les surfaces sont proportionnelles aux valeurs d’une variable et dont la couleur représente les modalités d’une variable qualitative. La fonction utilise les arguments des fonctions mf_map(..., type = \"prop\") et mf_map(..., type = \"typo\").\n\nmf_map(x = com)\nmf_map(\n  x = com,\n  var = c(\"POPULATION\", \"STATUT\"),\n  type = \"prop_typo\",\n  pal = c(\"aquamarine4\", \"yellow3\",\"wheat\"),\n  val_order = c(\"Préfecture\", \"Sous-préfecture\", \"Commune simple\"),\n  leg_pos = c(\"bottomleft\",\"topleft\"),\n  leg_title = c(\"Population\\n(2015)\",\n                \"Statut administratif\"),\n)\nmf_title(\"Population\")"
  },
  {
    "objectID": "type_de_carte.html#exercice---cartographie-simple",
    "href": "type_de_carte.html#exercice---cartographie-simple",
    "title": "4  Les types de cartes",
    "section": "4.8 Exercice - Cartographie simple",
    "text": "4.8 Exercice - Cartographie simple\n\nCette exercice utilise les données du projet RStudio geodata.\nTélécharger le projet\nImporter la couche des communes du département du Lot à partir du fichier geopackage lot.gpkg.\nImporter le fichier com.csv.\nCe jeu de données porte sur les communes du Lot et contient plusieurs variables supplémentaires:\n\nle nombre d’actifs (ACT).\nle nombre d’actifs dans l’industrie (IND)\nla part des actifs dans la population totale (SACT)\nla part des actifs dans l’industrie dans le total des actifs (SACT_IND)\n\nJoindre le jeu de données et la couche des communes.\nCréer une carte de la population active.\nQuel mode de représentation utiliser? Quels choix cela implique-t-il?\nCréer une carte de la part de la population active dans la population totale.\nQuel mode de représentation utiliser? Quels choix cela implique-t-il?\n\n\n\n\n\n\n\nVous pouvez utiliser le fichier exo_cartographie_simple.R pour vous guider dans cette exercice.\nVous trouverez la correction de cette exercice dans le fichier exo_cartographie_simple_correction.R"
  },
  {
    "objectID": "mise_en_page.html#les-thèmes",
    "href": "mise_en_page.html#les-thèmes",
    "title": "5  Mise en page",
    "section": "5.1 Les thèmes",
    "text": "5.1 Les thèmes\nLa fonction mf_theme() défini un thème cartographique. L’utilisation d’un thème permet de définir plusieurs paramètres graphiques qui sont ensuite appliqués aux cartes créées avec mapsf. Ces paramètres sont : les marges de la carte, la couleur principale, la couleur de fond, la position et l’aspect du titre. Un thème peut également être défini avec les fonctions mf_init() et mf_export().\n\n5.1.1 Utiliser un thème prédéfini\nUne série de thèmes prédéfinis est disponible par défaut (voir ?mf_theme).\n\nlibrary(mapsf)\n# utilisation d'une couleur de fond pour la figure, pour voir l'utilisation des marges\nopar &lt;- par(mfrow = c(2,2))\n# Utilisation d'un thème prédéfini\nmf_theme(\"default\")\nmf_map(com)\nmf_title(\"Theme : 'default'\")\nmf_theme(\"darkula\")\nmf_map(com)\nmf_title(\"Theme : 'darkula'\")\nmf_theme(\"candy\")\nmf_map(com)\nmf_title(\"Theme : 'candy'\")\nmf_theme(\"nevermind\")\nmf_map(com)\nmf_title(\"Theme : 'nevermind'\")\npar(opar)\n\n\n\n\n\n\n5.1.2 Modifier un thème existant\nIl est possible de modifier un thème existant. Dans cet exemple, nous utilisons le thème “default” et nous en modifions quelques paramètres.\n\nlibrary(mapsf)\nopar &lt;- par(mfrow = c(1,2))\nmf_theme(\"default\")\nmf_map(com)\nmf_title(\"default\")\nmf_theme(\n  \"default\",\n  tab = FALSE,\n  font = 4,\n  bg = \"grey60\",\n  pos = \"center\"\n)\nmf_map(com)\nmf_title(\"modified default\")\npar(opar)\n\n\n\n\n\n\n5.1.3 Créer un thème\nIl est également possible de créer un thème.\n\nmf_theme(\n  bg = \"lightblue\",    # couleur de fond\n  fg = \"tomato1\",      # couleur principale\n  mar = c(0,0,1.5,0),  # marges\n  tab = FALSE,         # style \"onglet\" pour le titre\n  inner = FALSE,       # titre à l'intérieur de la zone de carte ou à l'extérieur\n  line = 1.5,          # espace dédié au titre\n  pos = \"center\",      # position du titre\n  cex = 1.2,           # taille du titre\n  font = 2             # type de fonte pour le titre\n)\nmf_map(com)\nmf_title(\"New theme\")"
  },
  {
    "objectID": "mise_en_page.html#les-titres",
    "href": "mise_en_page.html#les-titres",
    "title": "5  Mise en page",
    "section": "5.2 Les titres",
    "text": "5.2 Les titres\nLa fonction mf_title() permet d’ajouter un titre à une carte.\n\nmf_theme(\"default\")\nmf_map(com)\nmf_title(\"Titre de la carte\")\n\n\n\n\nIl est possible de personnaliser l’aspect du titre.\n\nmf_map(com)\nmf_title(\n  txt = \"Titre de la carte\", \n  pos = \"center\", \n  tab = FALSE, \n  bg = \"tomato3\", \n  fg = \"lightblue\", \n  cex = 1, \n  line = 1.2, \n  font = 1, \n  inner = FALSE\n)"
  },
  {
    "objectID": "mise_en_page.html#flèche-dorientation",
    "href": "mise_en_page.html#flèche-dorientation",
    "title": "5  Mise en page",
    "section": "5.3 Flèche d’orientation",
    "text": "5.3 Flèche d’orientation\nLa fonction mf_arrow() permet de choisir la position et l’aspect de la flèche d’orientation.\n\nmf_map(com)\nmf_arrow()"
  },
  {
    "objectID": "mise_en_page.html#échelle",
    "href": "mise_en_page.html#échelle",
    "title": "5  Mise en page",
    "section": "5.4 Échelle",
    "text": "5.4 Échelle\nLa fonction mf_scale() permet de choisir la position et l’aspect de l’échelle.\n\nmf_map(com)\nmf_scale(\n  size = 20,\n  lwd = 2,\n  cex = 1.2,\n)"
  },
  {
    "objectID": "mise_en_page.html#crédits",
    "href": "mise_en_page.html#crédits",
    "title": "5  Mise en page",
    "section": "5.5 Crédits",
    "text": "5.5 Crédits\nLa fonction mf_credits() permet d’afficher une ligne de crédits (sources, auteur…).\n\nmf_map(com)\nmf_credits(\"Source: ..... \\nAuthors: ............\")"
  },
  {
    "objectID": "mise_en_page.html#habillage-complet",
    "href": "mise_en_page.html#habillage-complet",
    "title": "5  Mise en page",
    "section": "5.6 Habillage complet",
    "text": "5.6 Habillage complet\nLa fonction mf_layout() permet d’afficher tous ces éléments.\n\nmf_map(com)\nmf_layout(\n  title = \"Le Lot\",\n  credits = \"Author: .......\\nSources: ................\",\n  arrow = TRUE\n)"
  },
  {
    "objectID": "mise_en_page.html#annotations",
    "href": "mise_en_page.html#annotations",
    "title": "5  Mise en page",
    "section": "5.7 Annotations",
    "text": "5.7 Annotations\n\n# Sélection d'une commune\ncahors &lt;- com[com$NOM_COM == \"Cahors\", ]\nmf_map(com)\nmf_annotation(\n  x = cahors, \n  txt = \"Cahors\", \n  halo = TRUE, \n  cex = 1.5\n)"
  },
  {
    "objectID": "mise_en_page.html#étiquettes",
    "href": "mise_en_page.html#étiquettes",
    "title": "5  Mise en page",
    "section": "5.8 Étiquettes",
    "text": "5.8 Étiquettes\nLa fonction mf_label() est dédiée à l’afichage d’étiquettes.\n\n# Selection des communes qui intersectent la \n# commune de Cahors\ncom_sel &lt;- com[st_intersects(com, com[com$NOM_COM == \"Cahors\", ], sparse = FALSE), ]\n\nmf_map(com_sel)\nmf_label(\n  x = com_sel,\n  var = \"NOM_COM\",\n  col= \"black\",\n  halo = TRUE,\n  overlap = FALSE, \n  lines = FALSE\n)\nmf_scale()\n\n\n\n\nL’argument halo = TRUE permet d’afficher un léger halo autour des étiquettes et l’argument overlap = FALSE permet de créer des étiquettes ne se recouvrant pas."
  },
  {
    "objectID": "mise_en_page.html#les-légendes",
    "href": "mise_en_page.html#les-légendes",
    "title": "5  Mise en page",
    "section": "5.9 Les légendes",
    "text": "5.9 Les légendes\n\nmf_map(com)\nmf_legend(\n  type = \"prop\", \n  val = c(1000,500,200,10), \n  inches = .4, \n  title = \"Population\", \n  pos = \"topleft\"\n)\nmf_legend(\n  type = \"choro\", \n  val = c(0,10,20,30,40),\n  pal = \"Greens\", \n  pos = \"bottomright\", \n  val_rnd = 0\n)"
  },
  {
    "objectID": "mise_en_page.html#centrer-la-carte-sur-une-région",
    "href": "mise_en_page.html#centrer-la-carte-sur-une-région",
    "title": "5  Mise en page",
    "section": "5.10 Centrer la carte sur une région",
    "text": "5.10 Centrer la carte sur une région\nLa fonction mf_init() permet d’initialiser une carte en la centrant sur une objet spatial.\n\nmf_init(x = com_sel)\n# equivalent à \n# mf_map(com, col = NA, border = NA)\nmf_map(com, add = TRUE)\nmf_map(com_sel, col = NA, border = \"red\", lwd = 2, add = TRUE)"
  },
  {
    "objectID": "mise_en_page.html#afficher-plusieurs-cartes-sur-la-même-figure",
    "href": "mise_en_page.html#afficher-plusieurs-cartes-sur-la-même-figure",
    "title": "5  Mise en page",
    "section": "5.11 Afficher plusieurs cartes sur la même figure",
    "text": "5.11 Afficher plusieurs cartes sur la même figure\nIl faut ici utiliser l’argument mfrow de la fonction par(). Le premier chiffre représente le nombre lignes et le deuxième le nombre de colonnes.\nPar exemple par(mfrow = c(1, 2)) (1 ligne et 2 colonnes) permet d’afficher deux cartes côte à côte.\n\n# define the figure layout (1 row, 2 columns)\npar(mfrow = c(1, 2))\n# define theme\nmf_theme(\"default\", mar = c(0,0,1.2,0), tab = FALSE, pos = \"center\")\n# first map\nmf_map(com)\nmf_map(com, \"TER_F\", \"prop\", \n       val_max = 4000, \n       leg_pos = \"topleft\", \n       leg_title = \"N.\")\n\n#&gt; 6 '0' values are not plotted on the map.\n\nmf_title(\"Tertiaire: Femmes\")\n# second map\nmf_map(com)\nmf_map(com, \"TER_H\", \"prop\", \n       val_max = 4000, \n       leg_pos = NA)\n\n#&gt; 21 '0' values are not plotted on the map.\n\nmf_title(\"Hommes\")"
  },
  {
    "objectID": "mise_en_page.html#export-des-cartes",
    "href": "mise_en_page.html#export-des-cartes",
    "title": "5  Mise en page",
    "section": "5.12 Export des cartes",
    "text": "5.12 Export des cartes\nmf_export() permet d’exporter des cartes en PNG ou en SVG.\nLe ratio hauteur/largeur de la carte correspondra au ratio hauteur/largeur d’un objet spatial.\nSi width est spécifié alors height est déduit du ratio hauteur/largeur de x, de la taille des marges de la figure et des dimensions du titre (du thème utilisé en somme).\nmf_export() peut aussi être utilisé pour définir un thème, ajouter de l’espace sur un ou plusieurs côté de la carte ou encore centrer la carte sur une zone particulière.\n\n\n\n\n\n\nToujours utiliser add = TRUE après un appel à mf_export() et ne pas oublier d’utiliser dev.off() pour finaliser l’export de la figure.\n\n\n\n\n#création d'un thème personnel\nmon_theme &lt;- mf_theme(\"candy\", bg = \"grey80\")\nmf_export(\n  x = com, \n  filename = \"img/com_default.png\",\n  width = 600, \n  theme = mon_theme\n)\nmf_map(com, add = TRUE)\nmf_title(\"Le Lot\")\ndev.off()\n\n\nL’emprise de cette carte est exactement celle de la région affichée.\nLors de l’export suivant nous ajoutons de l’espace sur la partie droite de la carte (50% de la largeur de x).\n\nmf_export(\n  x = com, \n  filename = \"img/com_expand.png\",\n  width = 600, \n  expandBB = c(0, 0, 0, .5), \n  theme = mon_theme\n)\nmf_map(com, add = TRUE)\nmf_title(\"Le Lot\")\ndev.off()"
  },
  {
    "objectID": "mise_en_page.html#ajouter-une-image-sur-une-carte",
    "href": "mise_en_page.html#ajouter-une-image-sur-une-carte",
    "title": "5  Mise en page",
    "section": "5.13 Ajouter une image sur une carte",
    "text": "5.13 Ajouter une image sur une carte\nCela peut être utile pour ajouter un logo, un pictogramme. La fonction readPNG() du package png permet l’ajout d’images sur une figure.\n\nmf_theme(\"default\", mar = c(0,0,0,0))\nlibrary(png)\n# import de l'image\nlogo &lt;- readPNG(\"img/Logo CG 46 - Bleu.png\")\n# dimension de l'image en unité de la carte\npp &lt;- dim(logo)[2:1] * 20\n# Définition d'un point d'encrage de l'image dans la figure, ici\n# le coin supérieur gauche de la bounding box du département\nxy &lt;- st_bbox(com)[c(1,4)]\nmf_map(com, col = \"#D1914D\", border = \"white\")\nrasterImage(\n  image   = logo,\n  xleft   = xy[1],\n  ybottom = xy[2] - pp[2],\n  xright  = xy[1] + pp[1],\n  ytop    = xy[2]\n)"
  },
  {
    "objectID": "mise_en_page.html#placer-précisément-un-élément-sur-la-carte",
    "href": "mise_en_page.html#placer-précisément-un-élément-sur-la-carte",
    "title": "5  Mise en page",
    "section": "5.14 Placer précisément un élément sur la carte",
    "text": "5.14 Placer précisément un élément sur la carte\nDans plusieurs fonctions de mapsf il est possible de placer des éléments d’habillage de manière interactive avec la position “interactive”.\n\n\n\n\n\n\n\nPlus généralement la fonction locator() permet de cliquer sur une figure et d’obtenir les coordonnées d’un point dans le système de coordonnées de la figure (de la carte). locator()peut être utilisée sur la plupart des graphiques (pas ceux produits avec ggplot2)."
  },
  {
    "objectID": "mise_en_page.html#ajouter-un-ombrage-à-une-couche",
    "href": "mise_en_page.html#ajouter-un-ombrage-à-une-couche",
    "title": "5  Mise en page",
    "section": "5.15 Ajouter un ombrage à une couche",
    "text": "5.15 Ajouter un ombrage à une couche\nLa fonction mf_shadow() permet de créer une ombre à une couche de polygones.\n\nmf_theme(\"default\")\nmf_shadow(com)\nmf_map(com, add=TRUE)"
  },
  {
    "objectID": "mise_en_page.html#création-de-cartons",
    "href": "mise_en_page.html#création-de-cartons",
    "title": "5  Mise en page",
    "section": "5.16 Création de cartons",
    "text": "5.16 Création de cartons\nLa fonction mf_inset_on() permet de démarrer la création d’un carton. Il faut ensuite “refermer” le carton avec mf_inset_off().\n\n# Démarer la figure sur Cahors et ses environs\nmf_init(\n  x = com_sel,\n  theme = \"agolalight\",\n  expandBB = c(0, 0, 0, .5) # ajout d'un espace sur la droite\n)\n\n# affichage de toutes les communes\nmf_map(com, add = TRUE)\n# affichage de la sélection de communes\nmf_map(com_sel, col = \"tomato4\", \n       border = \"tomato1\", lwd = 2, add = TRUE)\n\n# Démarrer le carton en haut à droite sur\n# le ratio width/height du département\n# avec une largeur d'1/3 de la largeur de la figure\nmf_inset_on(x = com, pos = \"topright\", cex = .3)\n# affichage de toutes les communes\nmf_map(com, lwd = .5, border = \"grey90\")\n# affichage des communes sélectionnées\nmf_map(\n  com_sel,\n  col = \"tomato4\",\n  border = \"tomato1\",\n  lwd = .5,\n  add = TRUE\n)\n# échelle\nmf_scale(size = 10, pos = \"bottomleft\", cex = .6, lwd = .5)\n# Fermer le carton\nmf_inset_off()\n\n# Ajouter titre et échelle\nmf_title(\"Cahors et ses environs\")\nmf_scale(5, pos = 'bottomleft')\n\n\n\n\n\n\n\n\n\n\nCarton “Carte du monde\n\n\n\nOn peut facilement créer un carton avec la position d’un point sur une carte du monde avec la fonction mf_worldmap() et mf_inset_on(x = \"worldmap\", ...).\n\nmf_map(com)\nmf_inset_on(x = \"worldmap\")\nmf_worldmap(com)\nmf_inset_off()"
  },
  {
    "objectID": "mise_en_page.html#exercice---cartographie-avec-mise-en-page",
    "href": "mise_en_page.html#exercice---cartographie-avec-mise-en-page",
    "title": "5  Mise en page",
    "section": "5.17 Exercice - Cartographie avec mise en page",
    "text": "5.17 Exercice - Cartographie avec mise en page\n\nCette exercice utilise les données du projet RStudio geodata.\nTélécharger le projet\nImporter la couche des communes du département du Lot à partir du fichier geopackage lot.gpkg.\nImporter le fichier com.csv.\nCe jeu de données porte sur les communes du lot et contient plusieurs variables supplémentaires:\n\nle nombre d’actifs (ACT).\nle nombre d’actifs dans l’industrie (IND)\nLa part des actifs dans la population totale (SACT)\nLa part des actifs dans l’industrie dans le total des actifs (SACT_IND)\n\nJoindre le jeu de données et la couche des communes.\nCréez une carte représentant la population active travaillant dans l’industrie.\nAjoutez les éléments d’habillage indispensables.\nUtilisez un thème personnalisé.\nAjoutez un carton de localisation du Lot.\nExportez la carte au format PNG avec 800 pixels de large.\nComment rendre la carte plus intelligible ? Allez-y !\n\n\n\n\n\n\n\nVous pouvez utiliser le fichier exo_cartographie_mise_en_page.R pour vous guider dans cette exercice.\nVous trouverez la correction de cette exercice dans le fichier exo_cartographie_mise_en_page_correction.R"
  },
  {
    "objectID": "introduction.html#présentation",
    "href": "introduction.html#présentation",
    "title": "6  Le package sf",
    "section": "6.1 Présentation",
    "text": "6.1 Présentation\n Le package sf (E. Pebesma, 2018) a été publié fin 2016 par Edzer Pebesma. Ce package permet l’import, l’export, la manipulation et l’affichage de données spatiales vectorielles. Pour cela sf s’appuie sur une série de bibliothèques spatiales : GDAL (GDAL/OGR contributors, 2022) et PROJ (PROJ contributors, 2021) pour les opérations d’import, d’export et de projection, et GEOS (GEOS contributors, 2021) pour les opérations de géotraitement (buffer, intersection…).\nCe package propose des objets simples (suivant le standard simple feature) dont la manipulation est assez aisée. Une attention particulière a été portée à la compatibilité du package avec la syntaxe pipe (|&gt; ou %&gt;%) et les opérateurs du tidyverse (Wickham et al., 2019).\n\n\n\nE. Pebesma et Bivand (2023)\n\n\n\n\n\n\n\n\nHistorique\n\n\n\nLe package sf est venu remplacer les packages sp (E. J. Pebesma et Bivand, 2005), rgeos (R. Bivand et Rundel, 2018) et rgdal (R. Bivand et al., 2018) en combinant leurs fonctionnalités dans un package unique plus ergonomique."
  },
  {
    "objectID": "introduction.html#ressources",
    "href": "introduction.html#ressources",
    "title": "6  Le package sf",
    "section": "6.2 Ressources",
    "text": "6.2 Ressources\n\nSite web du package sf\nSimple Features for R\nEn savoir plus sur l’écosystème spatial de R\nProgress in the R ecosystem for representing and handling spatial data (R. S. Bivand, 2021)\nCRAN Task View\nAnalysis of Spatial Data\nListe de discussion\nR Special Interest Group on using Geographical data and Mapping\nManuel en anglais\nGeocomputation with R (Lovelace et al., 2019)\n\n\n\n\n\nBivand, R. S. (2021). Progress in the R ecosystem for representing and handling spatial data. Journal of Geographical Systems, 23(4), 515‑546. https://doi.org/10.1007/s10109-020-00336-0\n\n\nBivand, R., Keitt, T. et Rowlingson, B. (2018). rgdal: Bindings for the ’Geospatial’ Data Abstraction Library. https://CRAN.R-project.org/package=rgdal\n\n\nBivand, R. et Rundel, C. (2018). rgeos: Interface to Geometry Engine - Open Source (’GEOS’). https://CRAN.R-project.org/package=rgeos\n\n\nGDAL/OGR contributors. (2022). GDAL/OGR Geospatial Data Abstraction software Library. Open Source Geospatial Foundation. https://doi.org/10.5281/zenodo.5884351\n\n\nGEOS contributors. (2021). GEOS coordinate transformation software library. Open Source Geospatial Foundation. https://libgeos.org/\n\n\nLovelace, R., Nowosad, J. et Muenchow, J. (2019). Geocomputation with R. CRC Press. https://r.geocompx.org/\n\n\nPebesma, E. (2018). Simple Features for R: Standardized Support for Spatial Vector Data. The R Journal, 10(1), 439‑446. https://doi.org/10.32614/RJ-2018-009\n\n\nPebesma, E. J. et Bivand, R. S. (2005). Classes and methods for spatial data in R. R News, 5(2), 9‑13. https://CRAN.R-project.org/doc/Rnews/\n\n\nPebesma, E. et Bivand, R. (2023). Spatial Data Science: With applications in R (p. 352). Chapman and Hall/CRC. https://r-spatial.org/book/\n\n\nPROJ contributors. (2021). PROJ coordinate transformation software library. Open Source Geospatial Foundation. https://proj.org/\n\n\nWickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L. D., François, R., Grolemund, G., Hayes, A., Henry, L., Hester, J., Kuhn, M., Pedersen, T. L., Miller, E., Bache, S. M., Müller, K., Ooms, J., Robinson, D., Seidel, D. P., Spinu, V., Takahashi, K., et al.Yutani, H. (2019). Welcome to the tidyverse. Journal of Open Source Software, 4(43), 1686. https://doi.org/10.21105/joss.01686"
  },
  {
    "objectID": "format.html",
    "href": "format.html",
    "title": "7  Format des objets sf",
    "section": "",
    "text": "Les objets sf sont des data.frame dont l’une des colonnes contient des géométries. Cette colonne est de la classe sfc (simple feature column) et chaque individu de la colonne est un sfg (simple feature geometry).\nCe format est très pratique dans la mesure ou les données et les géométries sont intrinsèquement liées dans un même objet.\n\n\n\n\n\n\nVignette décrivant le format simple feature\n\n\n\nSimple Features for R"
  },
  {
    "objectID": "import.html#import",
    "href": "import.html#import",
    "title": "8  Import et export",
    "section": "8.1 Import",
    "text": "8.1 Import\nLes lignes suivantes importent la couche des communes du département du Lot situé dans le fichier geopackage lot.gpkg.\n\nlibrary(sf)\n\n#&gt; Linking to GEOS 3.9.0, GDAL 3.2.2, PROJ 7.2.1; sf_use_s2() is TRUE\n\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\")\n\n#&gt; Reading layer `communes' from data source \n#&gt;   `/home/tim/Documents/prz/PUDS_2023/PUDS_2023/data/lot.gpkg' \n#&gt;   using driver `GPKG'\n#&gt; Simple feature collection with 313 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668\n#&gt; Projected CRS: RGF93 / Lambert-93\n\n\n\n\n\n\n\n\nGeopackage\n\n\n\nLa fonction st_layers() permet d’avoir un aperçu des couches présentes dans un fichier geopackage.\n\nst_layers(\"data/lot.gpkg\")\n\n#&gt; Driver: GPKG \n#&gt; Available layers:\n#&gt;     layer_name geometry_type features fields           crs_name\n#&gt; 1     communes Multi Polygon      313     12 RGF93 / Lambert-93\n#&gt; 2 departements Multi Polygon       96      5 RGF93 / Lambert-93\n#&gt; 3  restaurants         Point      694      2 RGF93 / Lambert-93\n#&gt; 4       routes   Line String     1054      1 RGF93 / Lambert-93\n#&gt; 5   elevations         Point     5228      1 RGF93 / Lambert-93"
  },
  {
    "objectID": "import.html#export",
    "href": "import.html#export",
    "title": "8  Import et export",
    "section": "8.2 Export",
    "text": "8.2 Export\nLes lignes suivantes exportent l’objet com dans la couche communes du geopackage com.gpkg dans le dossier data.\n\nst_write(obj = com, dsn = \"data/com.gpkg\", layer = \"communes\")\n\n#&gt; Writing layer `communes' to data source `data/com.gpkg' using driver `GPKG'\n#&gt; Writing 313 features with 12 fields and geometry type Multi Polygon."
  },
  {
    "objectID": "afichage.html#aperçu-des-variables",
    "href": "afichage.html#aperçu-des-variables",
    "title": "9  Exploration et affichage",
    "section": "9.1 Aperçu des variables",
    "text": "9.1 Aperçu des variables\nLes objets sf sont des data.frame.\nNous pouvons utiliser les fonctions head() ou summary().\n\nlibrary(sf)\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\nhead(com)\n\n#&gt; Simple feature collection with 6 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 556391.9 ymin: 6371852 xmax: 614866.5 ymax: 6418606\n#&gt; Projected CRS: RGF93 / Lambert-93\n#&gt;   INSEE_COM         NOM_COM         STATUT POPULATION     AGR_H    AGR_F\n#&gt; 1     46001           Albas Commune simple        522  4.978581 0.000000\n#&gt; 2     46002          Albiac Commune simple         67  0.000000 9.589041\n#&gt; 3     46003        Alvignac Commune simple        706 10.419682 0.000000\n#&gt; 4     46004         Anglars Commune simple        219  0.000000 0.000000\n#&gt; 5     46005 Anglars-Juillac Commune simple        329  4.894895 4.894895\n#&gt; 6     46006   Anglars-Nozac Commune simple        377  4.840849 0.000000\n#&gt;       IND_H     IND_F     BTP_H    BTP_F     TER_H     TER_F\n#&gt; 1  4.936153  0.000000  9.957527 0.000000 44.917145 34.681799\n#&gt; 2  0.000000  0.000000  4.794521 0.000000  4.794521  9.589041\n#&gt; 3 10.419682  5.209841 10.419682 0.000000 57.308249 78.147612\n#&gt; 4 20.000000 15.000000 10.000000 0.000000 20.000000 20.000000\n#&gt; 5  4.894895  0.000000  0.000000 0.000000 29.369369 29.369369\n#&gt; 6  0.000000  0.000000  9.681698 4.840849 43.567639 38.726790\n#&gt;                             geom\n#&gt; 1 MULTIPOLYGON (((559262 6371...\n#&gt; 2 MULTIPOLYGON (((605540.7 64...\n#&gt; 3 MULTIPOLYGON (((593707.7 64...\n#&gt; 4 MULTIPOLYGON (((613211.3 64...\n#&gt; 5 MULTIPOLYGON (((556744.9 63...\n#&gt; 6 MULTIPOLYGON (((576667.2 64...\n\nsummary(com)\n\n#&gt;   INSEE_COM           NOM_COM             STATUT            POPULATION     \n#&gt;  Length:313         Length:313         Length:313         Min.   :   49.0  \n#&gt;  Class :character   Class :character   Class :character   1st Qu.:  172.0  \n#&gt;  Mode  :character   Mode  :character   Mode  :character   Median :  300.0  \n#&gt;                                                           Mean   :  555.7  \n#&gt;                                                           3rd Qu.:  529.0  \n#&gt;                                                           Max.   :19907.0  \n#&gt;      AGR_H            AGR_F            IND_H             IND_F        \n#&gt;  Min.   : 0.000   Min.   : 0.000   Min.   :  0.000   Min.   :  0.000  \n#&gt;  1st Qu.: 0.000   1st Qu.: 0.000   1st Qu.:  4.843   1st Qu.:  0.000  \n#&gt;  Median : 5.000   Median : 0.000   Median :  5.516   Median :  4.943  \n#&gt;  Mean   : 6.935   Mean   : 2.594   Mean   : 16.395   Mean   :  7.635  \n#&gt;  3rd Qu.:10.013   3rd Qu.: 5.000   3rd Qu.: 19.715   3rd Qu.:  9.905  \n#&gt;  Max.   :56.179   Max.   :24.641   Max.   :602.867   Max.   :184.016  \n#&gt;      BTP_H             BTP_F             TER_H             TER_F        \n#&gt;  Min.   :  0.000   Min.   : 0.0000   Min.   :   0.00   Min.   :   0.00  \n#&gt;  1st Qu.:  0.000   1st Qu.: 0.0000   1st Qu.:  10.00   1st Qu.:  15.15  \n#&gt;  Median :  5.000   Median : 0.0000   Median :  20.00   Median :  30.26  \n#&gt;  Mean   :  9.572   Mean   : 0.9723   Mean   :  42.17   Mean   :  60.77  \n#&gt;  3rd Qu.: 10.329   3rd Qu.: 0.0000   3rd Qu.:  44.69   3rd Qu.:  63.95  \n#&gt;  Max.   :203.122   Max.   :16.9238   Max.   :1778.87   Max.   :2397.18  \n#&gt;             geom    \n#&gt;  MULTIPOLYGON :313  \n#&gt;  epsg:2154    :  0  \n#&gt;  +proj=lcc ...:  0  \n#&gt;                     \n#&gt;                     \n#&gt; \n\n\n\n\n\n\n\n\nSupprimer la colonne de géométrie d’un objet sf\n\n\n\nPour transformer un objet sf en data.frame “pur” nous pouvons utiliser les fonctions st_set_geometry() ou st_drop_geometry().\n\ncom_df1 &lt;- st_set_geometry(com, NULL)\ncom_df2 &lt;- st_drop_geometry(com)\nidentical(com_df1, com_df2)\n\n#&gt; [1] TRUE\n\nhead(com_df1)\n\n#&gt;   INSEE_COM         NOM_COM         STATUT POPULATION     AGR_H    AGR_F\n#&gt; 1     46001           Albas Commune simple        522  4.978581 0.000000\n#&gt; 2     46002          Albiac Commune simple         67  0.000000 9.589041\n#&gt; 3     46003        Alvignac Commune simple        706 10.419682 0.000000\n#&gt; 4     46004         Anglars Commune simple        219  0.000000 0.000000\n#&gt; 5     46005 Anglars-Juillac Commune simple        329  4.894895 4.894895\n#&gt; 6     46006   Anglars-Nozac Commune simple        377  4.840849 0.000000\n#&gt;       IND_H     IND_F     BTP_H    BTP_F     TER_H     TER_F\n#&gt; 1  4.936153  0.000000  9.957527 0.000000 44.917145 34.681799\n#&gt; 2  0.000000  0.000000  4.794521 0.000000  4.794521  9.589041\n#&gt; 3 10.419682  5.209841 10.419682 0.000000 57.308249 78.147612\n#&gt; 4 20.000000 15.000000 10.000000 0.000000 20.000000 20.000000\n#&gt; 5  4.894895  0.000000  0.000000 0.000000 29.369369 29.369369\n#&gt; 6  0.000000  0.000000  9.681698 4.840849 43.567639 38.726790"
  },
  {
    "objectID": "afichage.html#affichage",
    "href": "afichage.html#affichage",
    "title": "9  Exploration et affichage",
    "section": "9.2 Affichage",
    "text": "9.2 Affichage\nAperçu des variables avec plot() :\n\nplot(com)\n\n#&gt; Warning: plotting the first 9 out of 12 attributes; use max.plot = 12 to plot\n#&gt; all\n\n\n\n\n\nAffichage d’une seule variable :\n\nplot(com[\"POPULATION\"])\n\n\n\n\nAffichage de la géométrie seule :\n\nplot(st_geometry(com))\n\n\n\n\nIl est aussi possible, comme nous l’avons vu précédement, d’utiliser le package mapsf pour afficher les objets sf\n\nmf_map(com, col = \"ivory4\", border = \"ivory\")"
  },
  {
    "objectID": "afichage.html#affichage-interactif",
    "href": "afichage.html#affichage-interactif",
    "title": "9  Exploration et affichage",
    "section": "9.3 Affichage interactif",
    "text": "9.3 Affichage interactif\n\nLe package mapview (Appelhans et al., 2022) permet d’afficher facilement des objets sf sur une carte interactive.\n\nlibrary(mapview)\nmapview(com)\n\n\n\n\n\n\n Pour combiner des couches il suffit d’utiliser le +.\n\nresto &lt;- sf::st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\nmapview(com) + mapview(resto)\n\n\n\n\n\n\n\n\n\n\nAppelhans, T., Detsch, F., Reudenbach, C. et Woellauer, S. (2022). mapview: Interactive Viewing of Spatial Data in R. https://CRAN.R-project.org/package=mapview"
  },
  {
    "objectID": "coords.html#consulter-le-système-de-coordonnées-dun-objet",
    "href": "coords.html#consulter-le-système-de-coordonnées-dun-objet",
    "title": "10  Les systèmes de coordonnées",
    "section": "10.1 Consulter le système de coordonnées d’un objet",
    "text": "10.1 Consulter le système de coordonnées d’un objet\nLa fonction st_crs() permet de consulter le système de coordonnées utilisé par un objet sf.\n\nlibrary(sf)\nst_crs(com)\n\n#&gt; Coordinate Reference System:\n#&gt;   User input: RGF93 / Lambert-93 \n#&gt;   wkt:\n#&gt; PROJCRS[\"RGF93 / Lambert-93\",\n#&gt;     BASEGEOGCRS[\"RGF93\",\n#&gt;         DATUM[\"Reseau Geodesique Francais 1993\",\n#&gt;             ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n#&gt;                 LENGTHUNIT[\"metre\",1]]],\n#&gt;         PRIMEM[\"Greenwich\",0,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#&gt;         ID[\"EPSG\",4171]],\n#&gt;     CONVERSION[\"Lambert-93\",\n#&gt;         METHOD[\"Lambert Conic Conformal (2SP)\",\n#&gt;             ID[\"EPSG\",9802]],\n#&gt;         PARAMETER[\"Latitude of false origin\",46.5,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8821]],\n#&gt;         PARAMETER[\"Longitude of false origin\",3,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8822]],\n#&gt;         PARAMETER[\"Latitude of 1st standard parallel\",49,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8823]],\n#&gt;         PARAMETER[\"Latitude of 2nd standard parallel\",44,\n#&gt;             ANGLEUNIT[\"degree\",0.0174532925199433],\n#&gt;             ID[\"EPSG\",8824]],\n#&gt;         PARAMETER[\"Easting at false origin\",700000,\n#&gt;             LENGTHUNIT[\"metre\",1],\n#&gt;             ID[\"EPSG\",8826]],\n#&gt;         PARAMETER[\"Northing at false origin\",6600000,\n#&gt;             LENGTHUNIT[\"metre\",1],\n#&gt;             ID[\"EPSG\",8827]]],\n#&gt;     CS[Cartesian,2],\n#&gt;         AXIS[\"easting (X)\",east,\n#&gt;             ORDER[1],\n#&gt;             LENGTHUNIT[\"metre\",1]],\n#&gt;         AXIS[\"northing (Y)\",north,\n#&gt;             ORDER[2],\n#&gt;             LENGTHUNIT[\"metre\",1]],\n#&gt;     USAGE[\n#&gt;         SCOPE[\"Engineering survey, topographic mapping.\"],\n#&gt;         AREA[\"France - onshore and offshore, mainland and Corsica.\"],\n#&gt;         BBOX[41.15,-9.86,51.56,10.38]],\n#&gt;     ID[\"EPSG\",2154]]"
  },
  {
    "objectID": "coords.html#modifier-le-système-de-coordonnées-dun-objet",
    "href": "coords.html#modifier-le-système-de-coordonnées-dun-objet",
    "title": "10  Les systèmes de coordonnées",
    "section": "10.2 Modifier le système de coordonnées d’un objet",
    "text": "10.2 Modifier le système de coordonnées d’un objet\nLa fonction st_transform() permet de changer le système de coordonnées d’un objet sf, de le reprojeter.\n\nmf_map(com)\nmf_title(\"RGF93 / Lambert-93\")\ncom_reproj &lt;- st_transform(com, \"epsg:3035\")\nmf_map(com_reproj)\nmf_title(\"ETRS89-extended / LAEA Europe\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLe site Spatial Reference met à disposition les références de très nombreux systèmes de coordonnées."
  },
  {
    "objectID": "geocodage.html#tidygeocoder",
    "href": "geocodage.html#tidygeocoder",
    "title": "11  Géocoder des adresses",
    "section": "11.1 tidygeocoder",
    "text": "11.1 tidygeocoder\n\nlibrary(tidygeocoder)\naddress_df &lt;- data.frame(\n  address = c(\"10 Emma Goldmanweg, 5032MN Tilburg, Netherlands\", \n              \"19 rue Michel Bakounine, 29600 Morlaix, France\")\n)\nplaces &lt;- geocode(.tbl = address_df, address = \"address\")\n\n#&gt; Passing 2 addresses to the Nominatim single address geocoder\n\n\n#&gt; Query completed in: 2 seconds\n\nplaces\n\n#&gt; # A tibble: 2 × 3\n#&gt;   address                                           lat  long\n#&gt;   &lt;chr&gt;                                           &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 10 Emma Goldmanweg, 5032MN Tilburg, Netherlands  51.5  5.04\n#&gt; 2 19 rue Michel Bakounine, 29600 Morlaix, France   48.6 -3.82\n\n\n\n\n\n\n\n\nSite web de tidygeocoder\n\n\n\ntidygeocoder"
  },
  {
    "objectID": "geocodage.html#transformer-les-données-longlat-en-objet-sf",
    "href": "geocodage.html#transformer-les-données-longlat-en-objet-sf",
    "title": "11  Géocoder des adresses",
    "section": "11.2 Transformer les données long/lat en objet sf",
    "text": "11.2 Transformer les données long/lat en objet sf\nLa fonction st_as_sf() permet de transformer un data.frame contenant des coordonnées géographiques en objet sf.\n\nIci nous utilisons le data.frame places créé au point précédent.\n\n\nlibrary(sf)\nplace_sf &lt;- st_as_sf(places, \n                     coords = c(\"long\", \"lat\"), \n                     crs = 4326)\nplace_sf\n\n#&gt; Simple feature collection with 2 features and 1 field\n#&gt; Geometry type: POINT\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: -3.816434 ymin: 48.59041 xmax: 5.038699 ymax: 51.53649\n#&gt; Geodetic CRS:  WGS 84\n#&gt; # A tibble: 2 × 2\n#&gt;   address                                                     geometry\n#&gt; * &lt;chr&gt;                                                    &lt;POINT [°]&gt;\n#&gt; 1 10 Emma Goldmanweg, 5032MN Tilburg, Netherlands  (5.038699 51.53649)\n#&gt; 2 19 rue Michel Bakounine, 29600 Morlaix, France  (-3.816435 48.59041)\n\n\n\nPour créer un objet sf de type POINT avec uniquement une paire de coordonnées. Ici le point de longitude 0.5 et de latitude 45.5 en WGS84 (EPSG:4326).\n\n\nlibrary(sf)\nmon_point &lt;- st_as_sf(data.frame(x = 0.5, y = 45.5), \n                      coords = c(\"x\", \"y\"), \n                      crs = 4326)\nmon_point\n\n#&gt; Simple feature collection with 1 feature and 0 fields\n#&gt; Geometry type: POINT\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 0.5 ymin: 45.5 xmax: 0.5 ymax: 45.5\n#&gt; Geodetic CRS:  WGS 84\n#&gt;           geometry\n#&gt; 1 POINT (0.5 45.5)\n\n\n\n\n\n\n\n\nNous pouvons afficher cet objet sf sur un fond de carte OpenStreetMap avec le package maptiles (Giraud, 2023).\n\nlibrary(maptiles)\nosm &lt;- get_tiles(x = place_sf, zoom = 7)\nmf_raster(osm)\nmf_map(place_sf, pch = 4, cex = 2, \n       lwd = 2, col = \"red\", add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\nCambon, J., Hernangómez, D., Belanger, C. et Possenriede, D. (2021). tidygeocoder: An R package for geocoding. Journal of Open Source Software, 6(65), 3544. https://doi.org/10.21105/joss.03544\n\n\nGiraud, T. (2023). maptiles: Download and Display Map Tiles. https://CRAN.R-project.org/package=maptiles"
  },
  {
    "objectID": "sel.html#sélection-par-attributs",
    "href": "sel.html#sélection-par-attributs",
    "title": "12  Les sélections",
    "section": "12.1 Sélection par attributs",
    "text": "12.1 Sélection par attributs\nLes objets sf sont des data.frame, on peut donc sélectionner leur lignes et leur colonnes de la même manière que les data.frame.\n\n# sélection de lignes\ncom[1:2, ]\n\n#&gt; Simple feature collection with 2 features and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 557759.2 ymin: 6371852 xmax: 607179 ymax: 6410204\n#&gt; Projected CRS: RGF93 / Lambert-93\n#&gt;   INSEE_COM NOM_COM         STATUT POPULATION    AGR_H    AGR_F    IND_H IND_F\n#&gt; 1     46001   Albas Commune simple        522 4.978581 0.000000 4.936153     0\n#&gt; 2     46002  Albiac Commune simple         67 0.000000 9.589041 0.000000     0\n#&gt;      BTP_H BTP_F     TER_H     TER_F                           geom\n#&gt; 1 9.957527     0 44.917145 34.681799 MULTIPOLYGON (((559262 6371...\n#&gt; 2 4.794521     0  4.794521  9.589041 MULTIPOLYGON (((605540.7 64...\n\ncom[com$NOM_COM == \"Gramat\", ]\n\n#&gt; Simple feature collection with 1 feature and 12 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 593605.6 ymin: 6402330 xmax: 602624.6 ymax: 6413784\n#&gt; Projected CRS: RGF93 / Lambert-93\n#&gt;     INSEE_COM NOM_COM         STATUT POPULATION    AGR_H    AGR_F    IND_H\n#&gt; 119     46128  Gramat Commune simple       3468 10.19868 15.29802 122.3842\n#&gt;        IND_F    BTP_H BTP_F    TER_H    TER_F                           geom\n#&gt; 119 107.0862 56.09275     0 260.0664 304.1941 MULTIPOLYGON (((594713.1 64...\n\n# sélection de colonnes\ncom[com$NOM_COM == \"Gramat\", 1:4]\n\n#&gt; Simple feature collection with 1 feature and 4 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 593605.6 ymin: 6402330 xmax: 602624.6 ymax: 6413784\n#&gt; Projected CRS: RGF93 / Lambert-93\n#&gt;     INSEE_COM NOM_COM         STATUT POPULATION                           geom\n#&gt; 119     46128  Gramat Commune simple       3468 MULTIPOLYGON (((594713.1 64...\n\ncom[, \"POPULATION\"]\n\n#&gt; Simple feature collection with 313 features and 1 field\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 539668.5 ymin: 6346290 xmax: 637380.9 ymax: 6439668\n#&gt; Projected CRS: RGF93 / Lambert-93\n#&gt; First 10 features:\n#&gt;    POPULATION                           geom\n#&gt; 1         522 MULTIPOLYGON (((559262 6371...\n#&gt; 2          67 MULTIPOLYGON (((605540.7 64...\n#&gt; 3         706 MULTIPOLYGON (((593707.7 64...\n#&gt; 4         219 MULTIPOLYGON (((613211.3 64...\n#&gt; 5         329 MULTIPOLYGON (((556744.9 63...\n#&gt; 6         377 MULTIPOLYGON (((576667.2 64...\n#&gt; 7         988 MULTIPOLYGON (((581404 6370...\n#&gt; 8         203 MULTIPOLYGON (((558216 6389...\n#&gt; 9         642 MULTIPOLYGON (((612729.6 63...\n#&gt; 10        367 MULTIPOLYGON (((581404 6370...\n\n\n\n\n\n\n\n\nNotez que la dernière sélection (com[, \"POPULATION\"]) conserve la colonne des géométries. La même opération sur un data.frame “pur” n’aurait sélectionné que le vecteur des valeurs de la colonne POPULATION :\n\ncom_df &lt;- st_drop_geometry(com)\ncom_df[, \"POPULATION\"]\n\n#&gt;   [1]   522    67   706   219   329   377   988   203   642   367   358   551\n#&gt;  [13]   178  1469   393   142   141   232   709   217   517   404   108   117\n#&gt;  [25]  1035  2090   344   134   400   577   323   184   132    88  1359   215\n#&gt;  [37]   228   157 19907   205   593  1120   457   168   205   147   373   257\n#&gt;  [49]   423   378  1103   105   610   411   222   223   180   428  1856   878\n#&gt;  [61]   449   632   171   168   569   309   421   413   231   346    97   102\n#&gt;  [73]   768    76   359  1129   314   238   620   662   819   957   144   210\n#&gt;  [85]   222    89   268  1045    97   108   294   672   452  9778  1000    96\n#&gt;  [97]   776   250   166   405   488   165   231   305   360   165    71   670\n#&gt; [109]   671   285   329   150   104   371   304   327   226  3985  3468   286\n#&gt; [121]   223   172   519   253   273    49   269  1235   936   205   354   166\n#&gt; [133]  1270   259   795    96   126  1735   697   123   301   586   350   139\n#&gt; [145]  1234   134   223   432   256   199   291   248   453   103   185   205\n#&gt; [157]   930   228   500   735   232   918   690   525   260   128   580    99\n#&gt; [169]  1802   203   356  1611   362   530   304   505   127  1127   273   457\n#&gt; [181]   182   358   104  1049   105   352   267  1739   543   215   596   332\n#&gt; [193]   122   300   289   158    65   363    71   155   381   623   665   443\n#&gt; [205]   188   350   782   529   190   167  3515  2394   230   224   719  1010\n#&gt; [217]    87  1965  1010   110    99   171   136   379   272   216   611   188\n#&gt; [229]   176   195    95    78    76   156   117    79  3479   311   178   141\n#&gt; [241]   342   198   124   161   142   214   638   690   191   329   529   565\n#&gt; [253]   878    63   242   398   256   868   185   208   214   178   204    94\n#&gt; [265]   317   403   178   211   158   338   179   475   142   201   442  1208\n#&gt; [277]   120   514   138   128   135   303    86   640   102  3243   122  1341\n#&gt; [289]   272   430   172   170   293   477   226   170   320   372   813    97\n#&gt; [301]   216   324   325  1303   327   175  1585   397   348   256    79   352\n#&gt; [313]   365\n\n\nPour obtenir le même résultat avec un objet sf on peut utiliser :\n\ncom[[\"POPULATION\"]]\n\n#&gt;   [1]   522    67   706   219   329   377   988   203   642   367   358   551\n#&gt;  [13]   178  1469   393   142   141   232   709   217   517   404   108   117\n#&gt;  [25]  1035  2090   344   134   400   577   323   184   132    88  1359   215\n#&gt;  [37]   228   157 19907   205   593  1120   457   168   205   147   373   257\n#&gt;  [49]   423   378  1103   105   610   411   222   223   180   428  1856   878\n#&gt;  [61]   449   632   171   168   569   309   421   413   231   346    97   102\n#&gt;  [73]   768    76   359  1129   314   238   620   662   819   957   144   210\n#&gt;  [85]   222    89   268  1045    97   108   294   672   452  9778  1000    96\n#&gt;  [97]   776   250   166   405   488   165   231   305   360   165    71   670\n#&gt; [109]   671   285   329   150   104   371   304   327   226  3985  3468   286\n#&gt; [121]   223   172   519   253   273    49   269  1235   936   205   354   166\n#&gt; [133]  1270   259   795    96   126  1735   697   123   301   586   350   139\n#&gt; [145]  1234   134   223   432   256   199   291   248   453   103   185   205\n#&gt; [157]   930   228   500   735   232   918   690   525   260   128   580    99\n#&gt; [169]  1802   203   356  1611   362   530   304   505   127  1127   273   457\n#&gt; [181]   182   358   104  1049   105   352   267  1739   543   215   596   332\n#&gt; [193]   122   300   289   158    65   363    71   155   381   623   665   443\n#&gt; [205]   188   350   782   529   190   167  3515  2394   230   224   719  1010\n#&gt; [217]    87  1965  1010   110    99   171   136   379   272   216   611   188\n#&gt; [229]   176   195    95    78    76   156   117    79  3479   311   178   141\n#&gt; [241]   342   198   124   161   142   214   638   690   191   329   529   565\n#&gt; [253]   878    63   242   398   256   868   185   208   214   178   204    94\n#&gt; [265]   317   403   178   211   158   338   179   475   142   201   442  1208\n#&gt; [277]   120   514   138   128   135   303    86   640   102  3243   122  1341\n#&gt; [289]   272   430   172   170   293   477   226   170   320   372   813    97\n#&gt; [301]   216   324   325  1303   327   175  1585   397   348   256    79   352\n#&gt; [313]   365"
  },
  {
    "objectID": "sel.html#sélection-spatiale",
    "href": "sel.html#sélection-spatiale",
    "title": "12  Les sélections",
    "section": "12.2 Sélection spatiale",
    "text": "12.2 Sélection spatiale\n\n12.2.1 Intersections\nSélection des routes intesectant la commune de Gramat.\n\nroute &lt;- st_read(\"data/lot.gpkg\", layer = \"routes\", quiet = TRUE)\ngramat &lt;-  com[com$NOM_COM == \"Gramat\", ]\ninter &lt;- st_intersects(x = route, y = gramat, sparse = FALSE)\nhead(inter)\n\n#&gt;       [,1]\n#&gt; [1,] FALSE\n#&gt; [2,] FALSE\n#&gt; [3,] FALSE\n#&gt; [4,]  TRUE\n#&gt; [5,] FALSE\n#&gt; [6,] FALSE\n\ndim(inter)\n\n#&gt; [1] 1054    1\n\n\nL’objet inter est une matrice qui indique pour chacun des éléments de route (1054 éléments) si il intersecte chacun des élément de gramat (1 élément).\nLa dimension de la matrice est donc bien 1054 lignes * 1 colonne.\nNotez l’utilisation du paramètre sparse = FALSE ici.\nIl est ensuite possible de créer une colonne à partir de cet objet :\n\nroute$intersect_gramat &lt;- inter[, 1]\n# selection des routes qui intersectent Gramat\nroute_gramat &lt;- route[route$intersect_gramat, ]\nmf_map(gramat, col = \"lightblue\")\nmf_map(route, add = TRUE)\nmf_map(route_gramat, col = \"tomato\", lwd = 2, add = TRUE)\n\n\n\n\n\n\n\n\n\n\nDifférence entre sparse = TRUE et sparse = FALSE\n\n\n\n\n\n\n\n\n\nsparse = TRUE\n\n\ninter &lt;- st_intersects(x = grid, y = pt, sparse = TRUE)\ninter\n\n#&gt; Sparse geometry binary predicate list of length 4, where the predicate\n#&gt; was `intersects'\n#&gt;  1: (empty)\n#&gt;  2: 6, 7\n#&gt;  3: 1, 4\n#&gt;  4: 2, 3, 5, 8\n\n\n\nsparse = FALSE\n\n\ninter &lt;- st_intersects(x = grid, y = pt, sparse = FALSE)\nrownames(inter) &lt;- grid$id\ncolnames(inter) &lt;- pt$id\ninter\n\n#&gt;       a     b     c     d     e     f     g     h\n#&gt; 1 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n#&gt; 2 FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE\n#&gt; 3  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n#&gt; 4 FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE\n\n\n\n\n\n\n12.2.2 Contains / Within\nSélection des routes contenues dans la commune de Gramat. La fonctin st_within() fonctionne comme la fonction st_intersects()\n\nwithin_g &lt;- st_within(route, gramat, sparse = FALSE)\nroute$within_gramat &lt;- within_g[, 1]\nroute_gramat2 &lt;- route[route$within_gramat, ]\nmf_map(gramat, col = \"lightblue\")\nmf_map(route, add = TRUE)\nmf_map(route_gramat2, col = \"tomato\", lwd = 2, add = TRUE)"
  },
  {
    "objectID": "operation.html#extraire-des-centroides",
    "href": "operation.html#extraire-des-centroides",
    "title": "13  Opérations sur les géométries",
    "section": "13.1 Extraire des centroides",
    "text": "13.1 Extraire des centroides\n\ncom_c &lt;- st_centroid(com)\n\n#&gt; Warning: st_centroid assumes attributes are constant over geometries\n\nmf_map(com)\nmf_map(com_c, add = TRUE, cex = 1.2, col = \"red\", pch = 20)"
  },
  {
    "objectID": "operation.html#agréger-des-polygones",
    "href": "operation.html#agréger-des-polygones",
    "title": "13  Opérations sur les géométries",
    "section": "13.2 Agréger des polygones",
    "text": "13.2 Agréger des polygones\n\ndep_46 &lt;- st_union(com)\nmf_map(com, col = \"lightblue\")\nmf_map(dep_46, col = NA, border = \"red\", lwd = 2, add = TRUE)"
  },
  {
    "objectID": "operation.html#agréger-des-polygones-en-fonction-dune-variable",
    "href": "operation.html#agréger-des-polygones-en-fonction-dune-variable",
    "title": "13  Opérations sur les géométries",
    "section": "13.3 Agréger des polygones en fonction d’une variable",
    "text": "13.3 Agréger des polygones en fonction d’une variable\nIl est possible d’utiliser la fonction aggregate().\n\ncom_u &lt;- aggregate(x = com[,c(\"POPULATION\")],\n                   by = list(STATUT = com$STATUT),\n                   FUN = \"sum\")\nmf_map(com_u, var = \"STATUT\", type = \"typo\")\n\n\n\n\nIl est aussi possible d’utiliser le package dplyr.\n\nlibrary(dplyr)\n\n#&gt; \n#&gt; Attaching package: 'dplyr'\n\n\n#&gt; The following objects are masked from 'package:stats':\n#&gt; \n#&gt;     filter, lag\n\n\n#&gt; The following objects are masked from 'package:base':\n#&gt; \n#&gt;     intersect, setdiff, setequal, union\n\ncom_u &lt;- com |&gt; \n  group_by(STATUT) |&gt;\n  summarise(pop = sum(POPULATION))"
  },
  {
    "objectID": "operation.html#construire-une-zone-tampon",
    "href": "operation.html#construire-une-zone-tampon",
    "title": "13  Opérations sur les géométries",
    "section": "13.4 Construire une zone tampon",
    "text": "13.4 Construire une zone tampon\n\ngramat &lt;- com[com$NOM_COM == \"Gramat\", ]\ngramat_b &lt;- st_buffer(x = gramat, dist = 5000)\nmf_map(gramat_b, col = \"lightblue\", lwd=2, border = \"red\")\nmf_map(gramat, add = TRUE, lwd = 2)"
  },
  {
    "objectID": "operation.html#réaliser-une-intersection",
    "href": "operation.html#réaliser-une-intersection",
    "title": "13  Opérations sur les géométries",
    "section": "13.5 Réaliser une intersection",
    "text": "13.5 Réaliser une intersection\nEn utilisant la fonction st_intersection() on va découper une couche par une autre.\n\n# création d'une zone tampon autour du centroid de la commune de Gramat\n# en utilisant le pipe\nzone &lt;- st_geometry(gramat) |&gt;\n  st_centroid() |&gt;\n  st_buffer(10000)\nmf_map(com)\nmf_map(zone, border = \"red\", col = NA, lwd = 2, add = TRUE)\n\n\n\ncom_z &lt;- st_intersection(x = com, y = zone)\n\n#&gt; Warning: attribute variables are assumed to be spatially constant throughout\n#&gt; all geometries\n\nmf_map(com)\nmf_map(com_z, col = \"red\", border = \"green\", add = TRUE)\n\n\n\nmf_map(com_z)"
  },
  {
    "objectID": "operation.html#créer-une-grille-régulière",
    "href": "operation.html#créer-une-grille-régulière",
    "title": "13  Opérations sur les géométries",
    "section": "13.6 Créer une grille régulière",
    "text": "13.6 Créer une grille régulière\nLa fonction st_make_grid() permet de créer une grille régulière. La fonction produit un objet sfc, il faut ensuite utiliser la fonction st_sf() pour transformer cet objet sfc en objet sf. Lors de cette transformation nous rajoutons ici une colonne d’identifiants uniques.\n\ngrid &lt;- st_make_grid(x = com, cellsize = 2500)\ngrid &lt;- st_sf(ID = 1:length(grid), geom = grid)\nmf_map(grid, col = \"grey\", border = \"white\")\nmf_map(com, col = NA, border = \"grey50\", add = TRUE)"
  },
  {
    "objectID": "operation.html#compter-des-points-dans-un-polygone",
    "href": "operation.html#compter-des-points-dans-un-polygone",
    "title": "13  Opérations sur les géométries",
    "section": "13.7 Compter des points dans un polygone",
    "text": "13.7 Compter des points dans un polygone\nNous allons compter le nombre de restaurants par carrés de la grille.\n\nrestaurant &lt;- st_read(\"data/lot.gpkg\", layer = \"restaurants\", quiet = TRUE)\nmf_map(grid, col = \"grey\", border = \"white\")\nmf_map(restaurant, pch = 20, col = \"red\", cex = .5, add = TRUE)\n\n\n\ninter &lt;- st_intersects(grid, restaurant, sparse = TRUE)\nlength(inter)\n\n#&gt; [1] 1520\n\n\nIci nous utilisons l’argument sparse = TRUE. L’objet inter est une liste de la longueur de l’objet grid et chaque élément de la liste contient l’index des éléments de l’objet restaurant qu’il intersecte.\nPar exemple le carreau 261 intersecte les restaurants 244 et 245 :\n\ninter[261]\n\n#&gt; [[1]]\n#&gt; [1] 244 245\n\nmf_map(grid[261, ])\nmf_map(restaurant[c(244, 245), ], add = TRUE)\n\n\n\n\nPour compter le nombre de restaurants il suffit de reporter la longueur de chacun des éléments de cette liste (avec la fonction lengths()).\n\ngrid$nb_restaurant &lt;- lengths(inter)\nmf_map(grid)\nmf_map(grid, var = \"nb_restaurant\", type = \"prop\", inches = .2, leg_frame = TRUE)\n\n#&gt; 1272 '0' values are not plotted on the map."
  },
  {
    "objectID": "operation.html#aggréger-les-valeurs-de-points-dans-des-polygones",
    "href": "operation.html#aggréger-les-valeurs-de-points-dans-des-polygones",
    "title": "13  Opérations sur les géométries",
    "section": "13.8 Aggréger les valeurs de points dans des polygones",
    "text": "13.8 Aggréger les valeurs de points dans des polygones\nIci nous voulons résumer l’information contenue dans une couche de points dans des polygones. Nous voulons connaître l’altitude minimale et maximale de chaque communes.\nNous pouvons commencer par importer une couche de points d’altitude (la couche elevations du fichier lot.gpkg)\n\nelev &lt;- st_read(\"data/lot.gpkg\", \"elevations\", quiet = TRUE)\n\nmf_map(elev, \"elevation\", \"choro\", \n       breaks = c(80, seq(100, 700, by = 100), 742),\n       pal = hcl.colors(8, \"Terrain2\"), \n       pch = 20, leg_pos = \"topleft\", cex = .5)\n\n\n\n\nL’objectif est d’agréger les valeurs de ces points (les altitudes contenues dans le champ elevation) dans les communes du Lot.\nEn utilisant la fonction st_join() nous pouvons récupérer les attributs des communes dans lesquelles se trouvent les points.\n\ninter &lt;- st_join(x = elev, y = com[, \"INSEE_COM\"])\ninter\n\n#&gt; Simple feature collection with 5228 features and 2 fields\n#&gt; Geometry type: POINT\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 540333.3 ymin: 6347372 xmax: 637333.3 ymax: 6439372\n#&gt; Projected CRS: RGF93 / Lambert-93\n#&gt; First 10 features:\n#&gt;    elevation INSEE_COM                     geom\n#&gt; 1   308.8546     46083 POINT (584333.3 6439372)\n#&gt; 2   304.6855     46083 POINT (582333.3 6438372)\n#&gt; 3   290.6638     46083 POINT (583333.3 6438372)\n#&gt; 4   295.0353     46083 POINT (584333.3 6438372)\n#&gt; 5   297.6773     46083 POINT (587333.3 6438372)\n#&gt; 6   257.7393     46083 POINT (588333.3 6438372)\n#&gt; 7   310.1883     46083 POINT (580333.3 6437372)\n#&gt; 8   305.0571     46083 POINT (581333.3 6437372)\n#&gt; 9   298.5876     46083 POINT (582333.3 6437372)\n#&gt; 10  287.6990     46083 POINT (583333.3 6437372)\n\n\nNous pouvons ensuite utiliser la fonction aggregate() pour agréger les altitudes par communes, d’abord l’altitude minimal, puis l’altitude maximale.\n\nalti_min &lt;- aggregate(x = list(alt_min = inter$elevation),\n                      by = list(INSEE_COM = inter$INSEE_COM),\n                      FUN = \"min\")\nalti_max &lt;- aggregate(x = list(alt_max = inter$elevation),\n                      by = list(INSEE_COM = inter$INSEE_COM),\n                      FUN = \"max\")\nhead(alti_max)\n\n#&gt;   INSEE_COM  alt_max\n#&gt; 1     46001 302.4913\n#&gt; 2     46002 393.9218\n#&gt; 3     46003 376.6632\n#&gt; 4     46004 448.6237\n#&gt; 5     46005 169.6282\n#&gt; 6     46006 281.1370\n\n\nOn peut ensuite combiner ces résultat à la couche des communes (avec la fonction merge()).\n\ncom &lt;- merge(com, alti_min, by = \"INSEE_COM\", all.x = TRUE)\ncom &lt;- merge(com, alti_max, by = \"INSEE_COM\", all.x = TRUE)\nhead(com)\n\n#&gt; Simple feature collection with 6 features and 14 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: 556391.9 ymin: 6371852 xmax: 614866.5 ymax: 6418606\n#&gt; Projected CRS: RGF93 / Lambert-93\n#&gt;   INSEE_COM         NOM_COM         STATUT POPULATION     AGR_H    AGR_F\n#&gt; 1     46001           Albas Commune simple        522  4.978581 0.000000\n#&gt; 2     46002          Albiac Commune simple         67  0.000000 9.589041\n#&gt; 3     46003        Alvignac Commune simple        706 10.419682 0.000000\n#&gt; 4     46004         Anglars Commune simple        219  0.000000 0.000000\n#&gt; 5     46005 Anglars-Juillac Commune simple        329  4.894895 4.894895\n#&gt; 6     46006   Anglars-Nozac Commune simple        377  4.840849 0.000000\n#&gt;       IND_H     IND_F     BTP_H    BTP_F     TER_H     TER_F  alt_min  alt_max\n#&gt; 1  4.936153  0.000000  9.957527 0.000000 44.917145 34.681799 109.5772 302.4913\n#&gt; 2  0.000000  0.000000  4.794521 0.000000  4.794521  9.589041 363.4579 393.9218\n#&gt; 3 10.419682  5.209841 10.419682 0.000000 57.308249 78.147612 258.8378 376.6632\n#&gt; 4 20.000000 15.000000 10.000000 0.000000 20.000000 20.000000 381.7637 448.6237\n#&gt; 5  4.894895  0.000000  0.000000 0.000000 29.369369 29.369369 101.2882 169.6282\n#&gt; 6  0.000000  0.000000  9.681698 4.840849 43.567639 38.726790 131.3722 281.1370\n#&gt;                         geometry\n#&gt; 1 MULTIPOLYGON (((559262 6371...\n#&gt; 2 MULTIPOLYGON (((605540.7 64...\n#&gt; 3 MULTIPOLYGON (((593707.7 64...\n#&gt; 4 MULTIPOLYGON (((613211.3 64...\n#&gt; 5 MULTIPOLYGON (((556744.9 63...\n#&gt; 6 MULTIPOLYGON (((576667.2 64...\n\n\n\nbks &lt;- c(80, seq(100, 700, by = 100), 742)\ncols &lt;- hcl.colors(8, \"Terrain2\")\nmf_map(com, \"alt_min\", \"choro\", breaks = bks, pal = cols)\nmf_map(com, \"alt_max\", \"choro\", breaks = bks, pal = cols)"
  },
  {
    "objectID": "mesures.html#créer-une-matrice-de-distances",
    "href": "mesures.html#créer-une-matrice-de-distances",
    "title": "14  Mesures",
    "section": "14.1 Créer une matrice de distances",
    "text": "14.1 Créer une matrice de distances\nSi le système de projection du jeu de données est renseigné les distances sont exprimées dans l’unité de mesure de la projection (en mètres le plus souvent).\n\nlibrary(sf)\ncom &lt;- st_read(\"data/lot.gpkg\", layer = \"communes\", quiet = TRUE)\ncom_c &lt;- st_centroid(com)\n\n#&gt; Warning: st_centroid assumes attributes are constant over geometries\n\nmat &lt;- st_distance(x = com_c, y = com_c)\nmat[1:5,1:5]\n\n#&gt; Units: [m]\n#&gt;           [,1]     [,2]     [,3]     [,4]      [,5]\n#&gt; [1,]     0.000 56784.77 54353.94 61166.42  3790.688\n#&gt; [2,] 56784.770     0.00 12454.29  7146.11 57288.103\n#&gt; [3,] 54353.942 12454.29     0.00 19388.52 54030.811\n#&gt; [4,] 61166.418  7146.11 19388.52     0.00 62016.141\n#&gt; [5,]  3790.688 57288.10 54030.81 62016.14     0.000"
  },
  {
    "objectID": "mesures.html#calcul-de-superficies",
    "href": "mesures.html#calcul-de-superficies",
    "title": "14  Mesures",
    "section": "14.2 Calcul de superficies",
    "text": "14.2 Calcul de superficies\nLa fonction st_area() permet de calculer des superficies.\n\nst_area(com)\n\n#&gt; Units: [m^2]\n#&gt;   [1]  21721665   3813205  13024216   9993074   5540367   9764463  23444541\n#&gt;   [8]  15046002  16632618  16293380   7372562  21630967  21053879  22275527\n#&gt;  [15]  15517187  10125054  27951257  15051792  24949950  18642367  36027875\n#&gt;  [22]   6582060   8962760   7026829  13916377   3660086  10794709  25801459\n#&gt;  [29]  13122352  49137354  13309178   7899993   5569618   8242635   5708356\n#&gt;  [36]  20791663  43959728   5260127  64835896  10170586   7545699  25753986\n#&gt;  [43]   7611435  33946541  17690834   7349503   6619585   5210855   8062691\n#&gt;  [50]  35077331  11002676   6951546  18201249  19059476  33966506  13474419\n#&gt;  [57]  11525583   5464519  85284308  21309699  10326222  10536668  15903498\n#&gt;  [64]  17534690  18654805  19054696  26028570   6113153  15399052  13566485\n#&gt;  [71]  21598754  10300137  15101184  18474515  19671699  41270659   9533978\n#&gt;  [78]   5001027  29467633  37856443   9138318  14996503  27910666  12311061\n#&gt;  [85]  17871469   9804348  35168583   6257629   7722856   5970916   8869839\n#&gt;  [92]  14001154  15047001  35333229  51554633   8144184  12623526  19040909\n#&gt;  [99]  13831821  15073907  16573203   3742606  13615983  16818901  23200605\n#&gt; [106]  11864772   2810177  12815822  40925808   9919053  15641478   9465172\n#&gt; [113]   6764338   4396382   2709328  35853843  10269115  45650856  57083907\n#&gt; [120]  17495797  10850551  11097487  19022305   9111536  13069556   9756570\n#&gt; [127]  10437517  28747237  70922749   9981628  12423054   8054857  11686854\n#&gt; [134]  21984608  31444013   8863415   3137349  52223414  10484037  11447363\n#&gt; [141]  13906862  14664234  22028787  24117395  37720371   5837872  11964040\n#&gt; [148]  10392019  23866362   6388917   8002728  15002654   8810453  13654119\n#&gt; [155]   5696374  10356509  10135986  13456369  14819632  32215211  12207847\n#&gt; [162]  15498046  26178360  23356999  12762361  15798721   6215775  10329747\n#&gt; [169]  22139435  26907446  22936550  35499484   9842051  16329336  12539141\n#&gt; [176]  15513388   6719966   7196803   8146216  25164758   5457470  12772916\n#&gt; [183]   9705794  22514580   8114419  21771816  20910600  78429296  13607462\n#&gt; [190]  11524881  26431325  11909159   6473331  11811656  27515162   7715703\n#&gt; [197]   7435900   4759480  16986059   8859531   5946528  19636923  21545217\n#&gt; [204]  25804959   2459306  28528199  19951986   5788246   7072706   8863765\n#&gt; [211]  16426300  24193388  15738774  14582021  12328467   4395657   7867932\n#&gt; [218]  26435807  21651662  25031841   5773989  12998321  15954597  12472749\n#&gt; [225]   9604541   7003255  49324917   6493743   6803072   9343352  12317013\n#&gt; [232]   8753756   3584760  16276984  10069300   9067423  11375267  26156776\n#&gt; [239]  13081877  18020025  32499690  18074926   7507306   8499102  10922860\n#&gt; [246]  11310527  42713532  46208639  10757297   7939989   7804276  21391535\n#&gt; [253]  31746827   8027105  21734266   5902100   9223566  10890631  13394177\n#&gt; [260]  10681221  13011131  11736466   5198299   7810404   7736132   5301966\n#&gt; [267]  10779522  12568495   5805238  15824674   9190195   8739797  13023601\n#&gt; [274]   9210600  19870252  29710680  25130430  10968916  11284216  26025312\n#&gt; [281]  18191271  18666825   7322605  19769216  11318417  26075906   7730761\n#&gt; [288] 140654332   9075439   8205551  10136442  13692632  16471822  12749087\n#&gt; [295]  13444859   8760834   8808194   4093506  20573134   6794678  12217187\n#&gt; [302]  25410357  26372085  16172102  17619760   9575085  34236255  23419492\n#&gt; [309]   7758204   7811781   7418188  12765559   8483450"
  },
  {
    "objectID": "exercice.html",
    "href": "exercice.html",
    "title": "15  Exercice",
    "section": "",
    "text": "Nous voulons connaitre le prix médian au mètre carré pour les appartements vendus entre 2016 et 2021 dans un voisinage de 500 mètres autour de la mairie de Montreuil.\nCette exercice utilise les données du projet RStudio geodata.\nTélécharger le projet\nPour cela nous disposons d’un jeu de données, le fichier dvf.gpkg contenu dans le dossier data du projet geodata. Il s’agit d’un geopackage qui contient 2 couches d’information :\n\ncom, les limites communales de Vincennes (94) et de Montreuil (93) (BD CARTO®, IGN, 2021),\ndvf, un extrait des appartements vendus entre 2016 et 2021 dans les communes de Vincennes et de Montreuil (Demandes de valeurs foncières géolocalisées, Etalab, 2021).\n\n\nExploration des données\n\nImportez les couches com et dvf du fichier dvf.gpkg\nIl faut utiliser la fonction st_read() du package sf.\nAffichez les 2 couches importées.\nQuel est le prix médian de l’ensemble des transactions ?\n\nGéocoder la mairie de Montreuil\n\nVoici l’adresse de la mairie de Montreuil : 1 Place Jean Jaurès, 93100 Montreuil.\nIl faut d’abord retrouver les coordonnées de la mairie à partir de son adresse. On peut utiliser le package tidygeocoder pour le faire.\nCréez un objet sf POINT à partir des coordonnées de la Mairie.\nIl faut utiliser la fonction st_as_sf().\nTransformez le système de coordonnées du point dans la même projection que com et dvf.\nIl faut utiliser la fonction st_transform().\n\nCréer un buffer de 500 m autour de la mairie\nIci on doit utiliser la fonction st_buffer().\nExtraire les appartements à l’intérieur du buffer et calculer le prix médian\nIci on peut utiliser la fonction st_intersection().\nExercice supplémentaire\nNous voulons connaître le prix médian des transactions dans une grille régulière.\nCréer un grille régulière (carreaux d’une surface de 5 hectares) sur l’emprise des communes.\nCalculer le prix médian des transactions par carreau.\nReprésenter ce prix médian sur une carte et ne représenter que les carreaux contenant au moins 10 transactions.\n\n\n\n\n\n\n\nVous pouvez utiliser le fichier exo_geomatique.R pour vous guider dans cette exercice.\nVous trouverez la correction de cette exercice dans le fichier exo_geomatique_correction.R"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Appelhans, T., Detsch, F., Reudenbach, C. et Woellauer, S. (2022).\nmapview: Interactive Viewing of Spatial Data in R. https://CRAN.R-project.org/package=mapview\n\n\nBertin, J. (1967). Sémiologie Graphique. Les Diagrammes -\nLes Réseaux - Les Cartes. Paris: Mouton &\nGauthier-Villars.\n\n\nBivand, R. S. (2021). Progress in the R ecosystem for\nrepresenting and handling spatial data. Journal of Geographical\nSystems, 23(4), 515‑546. https://doi.org/10.1007/s10109-020-00336-0\n\n\nBivand, R., Keitt, T. et Rowlingson, B. (2018). rgdal: Bindings for\nthe ’Geospatial’ Data Abstraction Library. https://CRAN.R-project.org/package=rgdal\n\n\nBivand, R. et Rundel, C. (2018). rgeos: Interface to Geometry Engine\n- Open Source (’GEOS’). https://CRAN.R-project.org/package=rgeos\n\n\nCambon, J., Hernangómez, D., Belanger, C. et Possenriede, D. (2021).\ntidygeocoder: An R package for geocoding. Journal of Open Source\nSoftware, 6(65), 3544. https://doi.org/10.21105/joss.03544\n\n\nDunnington, D. (2023). ggspatial: Spatial Data Framework for\nggplot2. https://CRAN.R-project.org/package=ggspatial\n\n\nGDAL/OGR contributors. (2022). GDAL/OGR Geospatial Data\nAbstraction software Library. Open Source Geospatial Foundation. https://doi.org/10.5281/zenodo.5884351\n\n\nGEOS contributors. (2021). GEOS coordinate\ntransformation software library. Open Source Geospatial Foundation.\nhttps://libgeos.org/\n\n\nGiraud, T. (2022). mapsf: Thematic Cartography. https://CRAN.R-project.org/package=mapsf\n\n\nGiraud, T. (2023). maptiles: Download and Display Map Tiles. https://CRAN.R-project.org/package=maptiles\n\n\nGiraud, T. et Lambert, N. (2017). Reproducible Cartography. M.\nPeterson (dir.), Cham, Switzerland (p. 173‑183). https://doi.org/10.1007/978-3-319-57336-6_13\n\n\nGiraud, T. et Pecout, H. (2023a). Cartographie avec R. https://doi.org/10.5281/zenodo.7528161\n\n\nGiraud, T. et Pecout, H. (2023b). Géomatique avec R. https://doi.org/10.5281/zenodo.7528145\n\n\nLambert, N. et Zanin, C. (2016). Manuel de cartographie: principes,\nméthodes, applications. Armand Colin.\n\n\nLovelace, R., Nowosad, J. et Muenchow, J. (2019). Geocomputation\nwith R. CRC Press. https://r.geocompx.org/\n\n\nPebesma, E. (2018). Simple Features for R: Standardized Support\nfor Spatial Vector Data. The R Journal,\n10(1), 439‑446. https://doi.org/10.32614/RJ-2018-009\n\n\nPebesma, E. J. et Bivand, R. S. (2005). Classes and methods for spatial\ndata in R. R News, 5(2), 9‑13. https://CRAN.R-project.org/doc/Rnews/\n\n\nPebesma, E. et Bivand, R. (2023). Spatial Data Science: With\napplications in R (p. 352). Chapman and\nHall/CRC. https://r-spatial.org/book/\n\n\nPROJ contributors. (2021). PROJ coordinate\ntransformation software library. Open Source Geospatial Foundation.\nhttps://proj.org/\n\n\nPumain, D. et Béguin, M. (2010). La représentation des\ndonnées géographiques: Statistique et\ncartographie. Armand Colin.\n\n\nTennekes, M. (2018). tmap: Thematic Maps in R.\nJournal of Statistical Software, 84(6), 1‑39. https://doi.org/10.18637/jss.v084.i06\n\n\nWickham, H. (2016). ggplot2: Elegant Graphics for Data\nAnalysis. Springer-Verlag New York. https://ggplot2.tidyverse.org\n\n\nWickham, H., Averick, M., Bryan, J., Chang, W., McGowan, L. D.,\nFrançois, R., Grolemund, G., Hayes, A., Henry, L., Hester, J., Kuhn, M.,\nPedersen, T. L., Miller, E., Bache, S. M., Müller, K., Ooms, J.,\nRobinson, D., Seidel, D. P., Spinu, V., Takahashi, K., et\nal.Yutani, H. (2019). Welcome to the tidyverse.\nJournal of Open Source Software, 4(43), 1686. https://doi.org/10.21105/joss.01686"
  }
]